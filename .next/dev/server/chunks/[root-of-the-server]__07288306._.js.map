{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahmanbazarov/Data/programming/BedRock/src/lib/supabase/server.ts"],"sourcesContent":["import { createServerClient } from '@supabase/ssr'\nimport { createClient as createSupabaseClient } from '@supabase/supabase-js'\nimport { cookies } from 'next/headers'\nimport { Database } from '@/types/database'\n\nexport async function createClient() {\n  const cookieStore = await cookies()\n\n  return createServerClient<Database>(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    {\n      cookies: {\n        getAll() {\n          return cookieStore.getAll()\n        },\n        setAll(cookiesToSet) {\n          try {\n            cookiesToSet.forEach(({ name, value, options }) =>\n              cookieStore.set(name, value, options)\n            )\n          } catch {\n            // The `setAll` method was called from a Server Component.\n            // This can be ignored if you have middleware refreshing\n            // user sessions.\n          }\n        },\n      },\n    }\n  )\n}\n\nexport function createServiceClient() {\n  return createSupabaseClient<Database>(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.SUPABASE_SERVICE_ROLE_KEY!,\n    {\n      auth: {\n        autoRefreshToken: false,\n        persistSession: false,\n      },\n    }\n  )\n}\n"],"names":[],"mappings":";;;;;;AAAA;AAAA;AACA;AACA;;;;AAGO,eAAe;IACpB,MAAM,cAAc,MAAM,IAAA,4IAAO;IAEjC,OAAO,IAAA,iMAAkB,sUAGvB;QACE,SAAS;YACP;gBACE,OAAO,YAAY,MAAM;YAC3B;YACA,QAAO,YAAY;gBACjB,IAAI;oBACF,aAAa,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,GAC5C,YAAY,GAAG,CAAC,MAAM,OAAO;gBAEjC,EAAE,OAAM;gBACN,0DAA0D;gBAC1D,wDAAwD;gBACxD,iBAAiB;gBACnB;YACF;QACF;IACF;AAEJ;AAEO,SAAS;IACd,OAAO,IAAA,gMAAoB,gFAEzB,QAAQ,GAAG,CAAC,yBAAyB,EACrC;QACE,MAAM;YACJ,kBAAkB;YAClB,gBAAgB;QAClB;IACF;AAEJ"}},
    {"offset": {"line": 174, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahmanbazarov/Data/programming/BedRock/src/lib/crypto/verify-signature.ts"],"sourcesContent":["import { ethers } from 'ethers'\nimport nacl from 'tweetnacl'\nimport bs58 from 'bs58'\nimport type { ChainId, WalletVerificationRequest } from './types'\n\nexport function generateChallengeMessage(address: string): string {\n  const nonce = Math.random().toString(36).substring(2, 15)\n  const timestamp = Date.now()\n  return `BedRock Wallet Verification\\n\\nAddress: ${address}\\nNonce: ${nonce}\\nTimestamp: ${timestamp}\\n\\nSign this message to verify wallet ownership.`\n}\n\nexport function verifyWalletSignature(req: WalletVerificationRequest): { valid: boolean; recoveredAddress?: string } {\n  try {\n    if (req.chain === 'solana') {\n      return verifySolana(req)\n    } else if (req.chain === 'tron') {\n      return verifyTron(req)\n    } else {\n      return verifyEvm(req)\n    }\n  } catch {\n    return { valid: false }\n  }\n}\n\nfunction verifyEvm(req: WalletVerificationRequest): { valid: boolean; recoveredAddress?: string } {\n  const recovered = ethers.verifyMessage(req.message, req.signature)\n  const valid = recovered.toLowerCase() === req.address.toLowerCase()\n  return { valid, recoveredAddress: recovered }\n}\n\nfunction verifySolana(req: WalletVerificationRequest): { valid: boolean; recoveredAddress?: string } {\n  const messageBytes = new TextEncoder().encode(req.message)\n  const signatureBytes = bs58.decode(req.signature)\n  const publicKeyBytes = bs58.decode(req.address)\n\n  const valid = nacl.sign.detached.verify(messageBytes, signatureBytes, publicKeyBytes)\n  return { valid, recoveredAddress: req.address }\n}\n\nfunction verifyTron(req: WalletVerificationRequest): { valid: boolean; recoveredAddress?: string } {\n  // Tron uses the same ECDSA as Ethereum, but with a different address format\n  // TronLink signs with personal_sign compatible format\n  const recovered = ethers.verifyMessage(req.message, req.signature)\n\n  // Convert Ethereum address to Tron format for comparison\n  // Tron addresses start with 'T' and use base58check with 0x41 prefix\n  // For verification, we compare the hex portion\n  const evmHex = recovered.toLowerCase().replace('0x', '')\n  const tronHex = tronAddressToHex(req.address).toLowerCase()\n\n  const valid = evmHex === tronHex\n  return { valid, recoveredAddress: req.address }\n}\n\nfunction tronAddressToHex(tronAddress: string): string {\n  if (tronAddress.startsWith('0x') || tronAddress.startsWith('0X')) {\n    return tronAddress.replace('0x', '').replace('0X', '')\n  }\n  // Base58 decode Tron address -> strip 0x41 prefix and 4-byte checksum\n  try {\n    const decoded = bs58.decode(tronAddress)\n    // Tron address: 1 byte prefix (0x41) + 20 bytes address + 4 bytes checksum\n    const addressBytes = decoded.slice(1, 21)\n    return Buffer.from(addressBytes).toString('hex')\n  } catch {\n    return ''\n  }\n}\n\nexport function isEvmChain(chain: ChainId): boolean {\n  return chain === 'ethereum' || chain === 'base' || chain === 'polygon'\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;;;;AAGO,SAAS,yBAAyB,OAAe;IACtD,MAAM,QAAQ,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,SAAS,CAAC,GAAG;IACtD,MAAM,YAAY,KAAK,GAAG;IAC1B,OAAO,CAAC,wCAAwC,EAAE,QAAQ,SAAS,EAAE,MAAM,aAAa,EAAE,UAAU,iDAAiD,CAAC;AACxJ;AAEO,SAAS,sBAAsB,GAA8B;IAClE,IAAI;QACF,IAAI,IAAI,KAAK,KAAK,UAAU;YAC1B,OAAO,aAAa;QACtB,OAAO,IAAI,IAAI,KAAK,KAAK,QAAQ;YAC/B,OAAO,WAAW;QACpB,OAAO;YACL,OAAO,UAAU;QACnB;IACF,EAAE,OAAM;QACN,OAAO;YAAE,OAAO;QAAM;IACxB;AACF;AAEA,SAAS,UAAU,GAA8B;IAC/C,MAAM,YAAY,4LAAM,CAAC,aAAa,CAAC,IAAI,OAAO,EAAE,IAAI,SAAS;IACjE,MAAM,QAAQ,UAAU,WAAW,OAAO,IAAI,OAAO,CAAC,WAAW;IACjE,OAAO;QAAE;QAAO,kBAAkB;IAAU;AAC9C;AAEA,SAAS,aAAa,GAA8B;IAClD,MAAM,eAAe,IAAI,cAAc,MAAM,CAAC,IAAI,OAAO;IACzD,MAAM,iBAAiB,wJAAI,CAAC,MAAM,CAAC,IAAI,SAAS;IAChD,MAAM,iBAAiB,wJAAI,CAAC,MAAM,CAAC,IAAI,OAAO;IAE9C,MAAM,QAAQ,sJAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,cAAc,gBAAgB;IACtE,OAAO;QAAE;QAAO,kBAAkB,IAAI,OAAO;IAAC;AAChD;AAEA,SAAS,WAAW,GAA8B;IAChD,4EAA4E;IAC5E,sDAAsD;IACtD,MAAM,YAAY,4LAAM,CAAC,aAAa,CAAC,IAAI,OAAO,EAAE,IAAI,SAAS;IAEjE,yDAAyD;IACzD,qEAAqE;IACrE,+CAA+C;IAC/C,MAAM,SAAS,UAAU,WAAW,GAAG,OAAO,CAAC,MAAM;IACrD,MAAM,UAAU,iBAAiB,IAAI,OAAO,EAAE,WAAW;IAEzD,MAAM,QAAQ,WAAW;IACzB,OAAO;QAAE;QAAO,kBAAkB,IAAI,OAAO;IAAC;AAChD;AAEA,SAAS,iBAAiB,WAAmB;IAC3C,IAAI,YAAY,UAAU,CAAC,SAAS,YAAY,UAAU,CAAC,OAAO;QAChE,OAAO,YAAY,OAAO,CAAC,MAAM,IAAI,OAAO,CAAC,MAAM;IACrD;IACA,sEAAsE;IACtE,IAAI;QACF,MAAM,UAAU,wJAAI,CAAC,MAAM,CAAC;QAC5B,2EAA2E;QAC3E,MAAM,eAAe,QAAQ,KAAK,CAAC,GAAG;QACtC,OAAO,OAAO,IAAI,CAAC,cAAc,QAAQ,CAAC;IAC5C,EAAE,OAAM;QACN,OAAO;IACT;AACF;AAEO,SAAS,WAAW,KAAc;IACvC,OAAO,UAAU,cAAc,UAAU,UAAU,UAAU;AAC/D"}},
    {"offset": {"line": 262, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahmanbazarov/Data/programming/BedRock/src/lib/crypto/on-chain-data.ts"],"sourcesContent":["import type { ChainId, OnChainData } from './types'\n\n// Etherscan API V2 — single endpoint, chain ID differentiates networks\nconst ETHERSCAN_V2_URL = 'https://api.etherscan.io/v2/api'\n\nconst EVM_CHAIN_IDS: Record<string, number> = {\n  ethereum: 1,\n  base: 8453,\n  polygon: 137,\n}\n\n// Stablecoin contract addresses (USDT, USDC, DAI) per EVM chain\nconst STABLECOINS: Record<string, { address: string; decimals: number }[]> = {\n  ethereum: [\n    { address: '0xdAC17F958D2ee523a2206206994597C13D831ec7', decimals: 6 }, // USDT\n    { address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48', decimals: 6 }, // USDC\n    { address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', decimals: 18 }, // DAI\n  ],\n  base: [\n    { address: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913', decimals: 6 }, // USDC\n  ],\n  polygon: [\n    { address: '0xc2132D05D31c914a87C6611C10748AEb04B58e8F', decimals: 6 }, // USDT\n    { address: '0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359', decimals: 6 }, // USDC\n    { address: '0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063', decimals: 18 }, // DAI\n  ],\n}\n\nexport async function fetchOnChainData(chain: ChainId, address: string): Promise<OnChainData> {\n  if (chain === 'solana') {\n    return fetchSolanaData(address)\n  }\n  if (chain === 'tron') {\n    return fetchTronData(address)\n  }\n  return fetchEvmData(chain, address)\n}\n\nasync function fetchEvmData(chain: ChainId, address: string): Promise<OnChainData> {\n  const chainId = EVM_CHAIN_IDS[chain]\n  if (!chainId) {\n    return emptyData(chain, address)\n  }\n\n  const apiKey = process.env.ETHERSCAN_API_KEY || ''\n\n  try {\n    // Etherscan V2: include chainid parameter\n    const txUrl = `${ETHERSCAN_V2_URL}?chainid=${chainId}&module=account&action=txlist&address=${address}&startblock=0&endblock=99999999&page=1&offset=100&sort=asc&apikey=${apiKey}`\n    const txRes = await fetch(txUrl, { next: { revalidate: 3600 } })\n    const txData = await txRes.json()\n\n    let firstTxTimestamp: number | null = null\n    let lastTxTimestamp: number | null = null\n    let txCount = 0\n\n    if (txData.status === '1' && Array.isArray(txData.result)) {\n      txCount = txData.result.length\n      if (txData.result.length > 0) {\n        firstTxTimestamp = parseInt(txData.result[0].timeStamp) * 1000\n        lastTxTimestamp = parseInt(txData.result[txData.result.length - 1].timeStamp) * 1000\n      }\n    }\n\n    // Fetch stablecoin balances\n    let stablecoinBalanceUsd = 0\n    const stablecoins = STABLECOINS[chain] || []\n    for (const coin of stablecoins) {\n      try {\n        const balUrl = `${ETHERSCAN_V2_URL}?chainid=${chainId}&module=account&action=tokenbalance&contractaddress=${coin.address}&address=${address}&tag=latest&apikey=${apiKey}`\n        const balRes = await fetch(balUrl, { next: { revalidate: 3600 } })\n        const balData = await balRes.json()\n        if (balData.status === '1' && balData.result) {\n          const raw = BigInt(balData.result)\n          const divisor = BigInt(10 ** coin.decimals)\n          stablecoinBalanceUsd += Number(raw / divisor)\n        }\n      } catch {\n        // Skip individual token errors\n      }\n    }\n\n    return {\n      chain,\n      address,\n      firstTxTimestamp,\n      lastTxTimestamp,\n      txCount,\n      stablecoinBalanceUsd,\n    }\n  } catch {\n    return emptyData(chain, address)\n  }\n}\n\nasync function fetchSolanaData(address: string): Promise<OnChainData> {\n  const RPC_URL = 'https://api.mainnet-beta.solana.com'\n\n  try {\n    // Fetch transaction signatures via native Solana RPC (free, no API key)\n    const txRes = await fetch(RPC_URL, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        jsonrpc: '2.0', id: 1,\n        method: 'getSignaturesForAddress',\n        params: [address, { limit: 100 }],\n      }),\n    })\n    const txData = await txRes.json()\n\n    let firstTxTimestamp: number | null = null\n    let lastTxTimestamp: number | null = null\n    let txCount = 0\n\n    if (Array.isArray(txData.result)) {\n      txCount = txData.result.length\n      if (txData.result.length > 0) {\n        // Sorted newest-first by default\n        lastTxTimestamp = txData.result[0].blockTime * 1000\n        firstTxTimestamp = txData.result[txData.result.length - 1].blockTime * 1000\n      }\n    }\n\n    // Fetch token balances via native Solana RPC\n    let stablecoinBalanceUsd = 0\n    try {\n      const tokenRes = await fetch(RPC_URL, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          jsonrpc: '2.0', id: 2,\n          method: 'getTokenAccountsByOwner',\n          params: [\n            address,\n            { programId: 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' },\n            { encoding: 'jsonParsed' },\n          ],\n        }),\n      })\n      const tokenData = await tokenRes.json()\n\n      // Solana stablecoin mints\n      const stableMints = new Set([\n        'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', // USDC\n        'Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB', // USDT\n      ])\n\n      if (Array.isArray(tokenData.result?.value)) {\n        for (const account of tokenData.result.value) {\n          const info = account.account?.data?.parsed?.info\n          if (info && stableMints.has(info.mint)) {\n            stablecoinBalanceUsd += info.tokenAmount?.uiAmount || 0\n          }\n        }\n      }\n    } catch {\n      // Skip token fetch errors\n    }\n\n    console.log(`[Solana] ${address}: ${txCount} txs, first=${firstTxTimestamp}, last=${lastTxTimestamp}, stables=$${stablecoinBalanceUsd}`)\n\n    return { chain: 'solana', address, firstTxTimestamp, lastTxTimestamp, txCount, stablecoinBalanceUsd }\n  } catch (err) {\n    console.log(`[Solana] Error:`, err)\n    return emptyData('solana', address)\n  }\n}\n\nasync function fetchTronData(address: string): Promise<OnChainData> {\n  const apiKey = process.env.TRONSCAN_API_KEY || ''\n\n  try {\n    const headers: Record<string, string> = { accept: 'application/json' }\n    if (apiKey) headers['TRON-PRO-API-KEY'] = apiKey\n\n    // Fetch account info\n    const accountUrl = `https://apilist.tronscanapi.com/api/accountv2?address=${address}`\n    const accountRes = await fetch(accountUrl, { headers, next: { revalidate: 3600 } })\n    const accountData = await accountRes.json()\n\n    const firstTxTimestamp = accountData.date_created ? accountData.date_created : null\n    const txCount = accountData.totalTransactionCount || 0\n\n    // Fetch recent transactions for last tx timestamp\n    let lastTxTimestamp: number | null = null\n    try {\n      const txUrl = `https://apilist.tronscanapi.com/api/transaction?sort=-timestamp&count=true&limit=1&address=${address}`\n      const txRes = await fetch(txUrl, { headers, next: { revalidate: 3600 } })\n      const txData = await txRes.json()\n      if (txData.data && txData.data.length > 0) {\n        lastTxTimestamp = txData.data[0].timestamp\n      }\n    } catch {\n      // Skip\n    }\n\n    // Check USDT balance on Tron (TRC-20)\n    let stablecoinBalanceUsd = 0\n    try {\n      const tokenUrl = `https://apilist.tronscanapi.com/api/account/tokens?address=${address}&token=trc20`\n      const tokenRes = await fetch(tokenUrl, { headers, next: { revalidate: 3600 } })\n      const tokenData = await tokenRes.json()\n\n      const stableIds = new Set([\n        'TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t', // USDT\n        'TEkxiTehnzSmSe2XqrBj4w32RUN966rdz8', // USDC\n      ])\n\n      if (Array.isArray(tokenData.data)) {\n        for (const token of tokenData.data) {\n          if (stableIds.has(token.tokenId)) {\n            const amount = Number(token.balance) / (10 ** (token.tokenDecimal || 6))\n            stablecoinBalanceUsd += amount\n          }\n        }\n      }\n    } catch {\n      // Skip\n    }\n\n    return { chain: 'tron', address, firstTxTimestamp, lastTxTimestamp, txCount, stablecoinBalanceUsd }\n  } catch {\n    return emptyData('tron', address)\n  }\n}\n\nfunction emptyData(chain: ChainId, address: string): OnChainData {\n  return {\n    chain,\n    address,\n    firstTxTimestamp: null,\n    lastTxTimestamp: null,\n    txCount: 0,\n    stablecoinBalanceUsd: 0,\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 551, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahmanbazarov/Data/programming/BedRock/src/lib/crypto/score-wallet.ts"],"sourcesContent":["import type { OnChainData, CryptoWalletScoreBreakdown } from './types'\n\nconst MAX_CRYPTO_SCORE = 15\n\nexport function scoreWallet(data: OnChainData): CryptoWalletScoreBreakdown {\n  const walletAge = scoreWalletAge(data.firstTxTimestamp)\n  const txCount = scoreTxCount(data.txCount)\n  const holdings = scoreHoldings(data.stablecoinBalanceUsd)\n  const activitySpread = scoreActivitySpread(data.firstTxTimestamp, data.lastTxTimestamp)\n\n  const total = Math.min(MAX_CRYPTO_SCORE, walletAge + txCount + holdings + activitySpread)\n\n  return { walletAge, txCount, holdings, activitySpread, total }\n}\n\nfunction scoreWalletAge(firstTxTimestamp: number | null): number {\n  if (!firstTxTimestamp) return 0\n  const ageMs = Date.now() - firstTxTimestamp\n  const ageYears = ageMs / (365.25 * 24 * 60 * 60 * 1000)\n\n  if (ageYears >= 2) return 4\n  if (ageYears >= 1) return 2\n  return 0\n}\n\nfunction scoreTxCount(count: number): number {\n  if (count >= 50) return 4\n  if (count >= 10) return 2\n  return 0\n}\n\nfunction scoreHoldings(usdBalance: number): number {\n  if (usdBalance >= 500) return 4\n  if (usdBalance >= 100) return 2\n  return 0\n}\n\nfunction scoreActivitySpread(firstTxTimestamp: number | null, lastTxTimestamp: number | null): number {\n  if (!firstTxTimestamp || !lastTxTimestamp) return 0\n  const spreadMs = lastTxTimestamp - firstTxTimestamp\n  const spreadMonths = spreadMs / (30 * 24 * 60 * 60 * 1000)\n\n  if (spreadMonths >= 6) return 3\n  if (spreadMonths >= 3) return 1\n  return 0\n}\n"],"names":[],"mappings":";;;;AAEA,MAAM,mBAAmB;AAElB,SAAS,YAAY,IAAiB;IAC3C,MAAM,YAAY,eAAe,KAAK,gBAAgB;IACtD,MAAM,UAAU,aAAa,KAAK,OAAO;IACzC,MAAM,WAAW,cAAc,KAAK,oBAAoB;IACxD,MAAM,iBAAiB,oBAAoB,KAAK,gBAAgB,EAAE,KAAK,eAAe;IAEtF,MAAM,QAAQ,KAAK,GAAG,CAAC,kBAAkB,YAAY,UAAU,WAAW;IAE1E,OAAO;QAAE;QAAW;QAAS;QAAU;QAAgB;IAAM;AAC/D;AAEA,SAAS,eAAe,gBAA+B;IACrD,IAAI,CAAC,kBAAkB,OAAO;IAC9B,MAAM,QAAQ,KAAK,GAAG,KAAK;IAC3B,MAAM,WAAW,QAAQ,CAAC,SAAS,KAAK,KAAK,KAAK,IAAI;IAEtD,IAAI,YAAY,GAAG,OAAO;IAC1B,IAAI,YAAY,GAAG,OAAO;IAC1B,OAAO;AACT;AAEA,SAAS,aAAa,KAAa;IACjC,IAAI,SAAS,IAAI,OAAO;IACxB,IAAI,SAAS,IAAI,OAAO;IACxB,OAAO;AACT;AAEA,SAAS,cAAc,UAAkB;IACvC,IAAI,cAAc,KAAK,OAAO;IAC9B,IAAI,cAAc,KAAK,OAAO;IAC9B,OAAO;AACT;AAEA,SAAS,oBAAoB,gBAA+B,EAAE,eAA8B;IAC1F,IAAI,CAAC,oBAAoB,CAAC,iBAAiB,OAAO;IAClD,MAAM,WAAW,kBAAkB;IACnC,MAAM,eAAe,WAAW,CAAC,KAAK,KAAK,KAAK,KAAK,IAAI;IAEzD,IAAI,gBAAgB,GAAG,OAAO;IAC9B,IAAI,gBAAgB,GAAG,OAAO;IAC9B,OAAO;AACT"}},
    {"offset": {"line": 600, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahmanbazarov/Data/programming/BedRock/src/lib/crypto/challenge-cache.ts"],"sourcesContent":["import { createHmac } from 'crypto'\n\n// Stateless challenge verification using HMAC.\n// No in-memory state needed — the challenge message itself contains\n// the timestamp and HMAC so the verify endpoint can validate it.\n\nconst CHALLENGE_TTL_MS = 5 * 60 * 1000 // 5 minutes\n\nfunction getSecret(): string {\n  return process.env.OAUTH_STATE_SECRET || 'dev-fallback-secret'\n}\n\nfunction hmac(data: string): string {\n  return createHmac('sha256', getSecret()).update(data).digest('hex')\n}\n\n/**\n * Create a signed challenge message. The message includes:\n * - The wallet address\n * - A timestamp\n * - A nonce\n * - An HMAC signature\n * The client signs this message, and the verify endpoint can validate\n * the HMAC without needing to look anything up.\n */\nexport function createSignedChallenge(address: string): string {\n  const timestamp = Date.now()\n  const nonce = Math.random().toString(36).substring(2, 10)\n  const payload = `${address.toLowerCase()}:${timestamp}:${nonce}`\n  const sig = hmac(payload)\n\n  // Human-readable message that the wallet will display\n  return `BedRock Wallet Verification\\n\\nAddress: ${address}\\nTimestamp: ${timestamp}\\nNonce: ${nonce}\\nSignature: ${sig}`\n}\n\n/**\n * Parse and validate a signed challenge message.\n * Returns the original message if valid and not expired, null otherwise.\n */\nexport function validateChallenge(message: string): { valid: boolean; address?: string } {\n  try {\n    const addressMatch = message.match(/Address: (.+)/)\n    const timestampMatch = message.match(/Timestamp: (\\d+)/)\n    const nonceMatch = message.match(/Nonce: (.+)/)\n    const sigMatch = message.match(/Signature: (.+)/)\n\n    if (!addressMatch || !timestampMatch || !nonceMatch || !sigMatch) {\n      return { valid: false }\n    }\n\n    const address = addressMatch[1].trim()\n    const timestamp = parseInt(timestampMatch[1].trim())\n    const nonce = nonceMatch[1].trim()\n    const sig = sigMatch[1].trim()\n\n    // Check expiry\n    if (Date.now() - timestamp > CHALLENGE_TTL_MS) {\n      return { valid: false }\n    }\n\n    // Verify HMAC\n    const payload = `${address.toLowerCase()}:${timestamp}:${nonce}`\n    const expectedSig = hmac(payload)\n\n    if (sig !== expectedSig) {\n      return { valid: false }\n    }\n\n    return { valid: true, address }\n  } catch {\n    return { valid: false }\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA;;AAEA,+CAA+C;AAC/C,oEAAoE;AACpE,iEAAiE;AAEjE,MAAM,mBAAmB,IAAI,KAAK,KAAK,YAAY;;AAEnD,SAAS;IACP,OAAO,QAAQ,GAAG,CAAC,kBAAkB,IAAI;AAC3C;AAEA,SAAS,KAAK,IAAY;IACxB,OAAO,IAAA,mHAAU,EAAC,UAAU,aAAa,MAAM,CAAC,MAAM,MAAM,CAAC;AAC/D;AAWO,SAAS,sBAAsB,OAAe;IACnD,MAAM,YAAY,KAAK,GAAG;IAC1B,MAAM,QAAQ,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,SAAS,CAAC,GAAG;IACtD,MAAM,UAAU,GAAG,QAAQ,WAAW,GAAG,CAAC,EAAE,UAAU,CAAC,EAAE,OAAO;IAChE,MAAM,MAAM,KAAK;IAEjB,sDAAsD;IACtD,OAAO,CAAC,wCAAwC,EAAE,QAAQ,aAAa,EAAE,UAAU,SAAS,EAAE,MAAM,aAAa,EAAE,KAAK;AAC1H;AAMO,SAAS,kBAAkB,OAAe;IAC/C,IAAI;QACF,MAAM,eAAe,QAAQ,KAAK,CAAC;QACnC,MAAM,iBAAiB,QAAQ,KAAK,CAAC;QACrC,MAAM,aAAa,QAAQ,KAAK,CAAC;QACjC,MAAM,WAAW,QAAQ,KAAK,CAAC;QAE/B,IAAI,CAAC,gBAAgB,CAAC,kBAAkB,CAAC,cAAc,CAAC,UAAU;YAChE,OAAO;gBAAE,OAAO;YAAM;QACxB;QAEA,MAAM,UAAU,YAAY,CAAC,EAAE,CAAC,IAAI;QACpC,MAAM,YAAY,SAAS,cAAc,CAAC,EAAE,CAAC,IAAI;QACjD,MAAM,QAAQ,UAAU,CAAC,EAAE,CAAC,IAAI;QAChC,MAAM,MAAM,QAAQ,CAAC,EAAE,CAAC,IAAI;QAE5B,eAAe;QACf,IAAI,KAAK,GAAG,KAAK,YAAY,kBAAkB;YAC7C,OAAO;gBAAE,OAAO;YAAM;QACxB;QAEA,cAAc;QACd,MAAM,UAAU,GAAG,QAAQ,WAAW,GAAG,CAAC,EAAE,UAAU,CAAC,EAAE,OAAO;QAChE,MAAM,cAAc,KAAK;QAEzB,IAAI,QAAQ,aAAa;YACvB,OAAO;gBAAE,OAAO;YAAM;QACxB;QAEA,OAAO;YAAE,OAAO;YAAM;QAAQ;IAChC,EAAE,OAAM;QACN,OAAO;YAAE,OAAO;QAAM;IACxB;AACF"}},
    {"offset": {"line": 670, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahmanbazarov/Data/programming/BedRock/src/lib/rate-limit.ts"],"sourcesContent":["const rateLimitMap = new Map<string, { count: number; resetAt: number }>()\n\n// Cleanup stale entries every 5 minutes\nsetInterval(() => {\n  const now = Date.now()\n  for (const [key, entry] of rateLimitMap) {\n    if (now > entry.resetAt) {\n      rateLimitMap.delete(key)\n    }\n  }\n}, 5 * 60_000)\n\nexport function checkRateLimit(\n  key: string,\n  maxRequests: number = 10,\n  windowMs: number = 60_000\n): { allowed: boolean; remaining: number; resetIn: number } {\n  const now = Date.now()\n  const entry = rateLimitMap.get(key)\n\n  if (!entry || now > entry.resetAt) {\n    rateLimitMap.set(key, { count: 1, resetAt: now + windowMs })\n    return { allowed: true, remaining: maxRequests - 1, resetIn: windowMs }\n  }\n\n  if (entry.count >= maxRequests) {\n    return { allowed: false, remaining: 0, resetIn: entry.resetAt - now }\n  }\n\n  entry.count++\n  return { allowed: true, remaining: maxRequests - entry.count, resetIn: entry.resetAt - now }\n}\n\nexport function getClientIp(request: Request): string {\n  const forwarded = request.headers.get('x-forwarded-for')\n  const realIp = request.headers.get('x-real-ip')\n  return forwarded?.split(',')[0]?.trim() || realIp || 'unknown'\n}\n"],"names":[],"mappings":";;;;;;AAAA,MAAM,eAAe,IAAI;AAEzB,wCAAwC;AACxC,YAAY;IACV,MAAM,MAAM,KAAK,GAAG;IACpB,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,aAAc;QACvC,IAAI,MAAM,MAAM,OAAO,EAAE;YACvB,aAAa,MAAM,CAAC;QACtB;IACF;AACF,GAAG,IAAI;AAEA,SAAS,eACd,GAAW,EACX,cAAsB,EAAE,EACxB,WAAmB,MAAM;IAEzB,MAAM,MAAM,KAAK,GAAG;IACpB,MAAM,QAAQ,aAAa,GAAG,CAAC;IAE/B,IAAI,CAAC,SAAS,MAAM,MAAM,OAAO,EAAE;QACjC,aAAa,GAAG,CAAC,KAAK;YAAE,OAAO;YAAG,SAAS,MAAM;QAAS;QAC1D,OAAO;YAAE,SAAS;YAAM,WAAW,cAAc;YAAG,SAAS;QAAS;IACxE;IAEA,IAAI,MAAM,KAAK,IAAI,aAAa;QAC9B,OAAO;YAAE,SAAS;YAAO,WAAW;YAAG,SAAS,MAAM,OAAO,GAAG;QAAI;IACtE;IAEA,MAAM,KAAK;IACX,OAAO;QAAE,SAAS;QAAM,WAAW,cAAc,MAAM,KAAK;QAAE,SAAS,MAAM,OAAO,GAAG;IAAI;AAC7F;AAEO,SAAS,YAAY,OAAgB;IAC1C,MAAM,YAAY,QAAQ,OAAO,CAAC,GAAG,CAAC;IACtC,MAAM,SAAS,QAAQ,OAAO,CAAC,GAAG,CAAC;IACnC,OAAO,WAAW,MAAM,IAAI,CAAC,EAAE,EAAE,UAAU,UAAU;AACvD"}},
    {"offset": {"line": 723, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahmanbazarov/Data/programming/BedRock/src/app/api/crypto/verify/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server'\nimport { createClient, createServiceClient } from '@/lib/supabase/server'\nimport { verifyWalletSignature } from '@/lib/crypto/verify-signature'\nimport { fetchOnChainData } from '@/lib/crypto/on-chain-data'\nimport { scoreWallet } from '@/lib/crypto/score-wallet'\nimport { validateChallenge } from '@/lib/crypto/challenge-cache'\nimport { checkRateLimit, getClientIp } from '@/lib/rate-limit'\nimport type { ChainId, CryptoWalletProfileData } from '@/lib/crypto/types'\n\nexport async function POST(request: Request) {\n  const ip = getClientIp(request)\n  const { allowed, resetIn } = checkRateLimit(`crypto-verify:${ip}`, 5, 60_000)\n  if (!allowed) {\n    return NextResponse.json(\n      { error: 'Too many requests' },\n      { status: 429, headers: { 'Retry-After': String(Math.ceil(resetIn / 1000)) } }\n    )\n  }\n\n  try {\n    const authClient = await createClient()\n    const supabase = createServiceClient()\n\n    const { data: { user }, error: userError } = await authClient.auth.getUser()\n    if (userError || !user) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const { data: founderData } = await supabase\n      .from('founders')\n      .select('id')\n      .eq('user_id', user.id)\n      .single()\n\n    const founder = founderData as { id: string } | null\n    if (!founder) {\n      return NextResponse.json({ error: 'Founder not found' }, { status: 404 })\n    }\n\n    const body = await request.json()\n    const { chain, address, signature, message } = body as {\n      chain: ChainId; address: string; signature: string; message: string\n    }\n\n    if (!chain || !address || !signature || !message) {\n      return NextResponse.json({ error: 'chain, address, signature, and message are required' }, { status: 400 })\n    }\n\n    // Validate the challenge message HMAC and expiry (stateless — no server lookup needed)\n    const challengeCheck = validateChallenge(message)\n    if (!challengeCheck.valid) {\n      return NextResponse.json({ error: 'Challenge expired or invalid. Request a new one.' }, { status: 400 })\n    }\n\n    // Verify wallet signature against the challenge message\n    const verification = verifyWalletSignature({\n      chain,\n      address,\n      signature,\n      message,\n    })\n\n    if (!verification.valid) {\n      return NextResponse.json({ error: 'Invalid signature' }, { status: 400 })\n    }\n\n    // Fetch on-chain data\n    const onChainData = await fetchOnChainData(chain, address)\n\n    console.log('\\n=== WALLET VERIFICATION ===')\n    console.log(`Chain: ${chain}`)\n    console.log(`Address: ${address}`)\n    console.log('--- On-Chain Data ---')\n    console.log(`  First tx: ${onChainData.firstTxTimestamp ? new Date(onChainData.firstTxTimestamp).toISOString() : 'none'}`)\n    console.log(`  Last tx:  ${onChainData.lastTxTimestamp ? new Date(onChainData.lastTxTimestamp).toISOString() : 'none'}`)\n    console.log(`  Tx count: ${onChainData.txCount}`)\n    console.log(`  Stablecoin balance: $${onChainData.stablecoinBalanceUsd}`)\n    if (onChainData.firstTxTimestamp) {\n      const ageYears = (Date.now() - onChainData.firstTxTimestamp) / (365.25 * 24 * 60 * 60 * 1000)\n      console.log(`  Wallet age: ${ageYears.toFixed(2)} years`)\n    }\n    if (onChainData.firstTxTimestamp && onChainData.lastTxTimestamp) {\n      const spreadMonths = (onChainData.lastTxTimestamp - onChainData.firstTxTimestamp) / (30 * 24 * 60 * 60 * 1000)\n      console.log(`  Activity spread: ${spreadMonths.toFixed(1)} months`)\n    }\n\n    // Score the wallet\n    const walletScore = scoreWallet(onChainData)\n\n    console.log('--- Score Breakdown ---')\n    console.log(`  Wallet age:       ${walletScore.walletAge}/4`)\n    console.log(`  Tx count:         ${walletScore.txCount}/4`)\n    console.log(`  Holdings:         ${walletScore.holdings}/4`)\n    console.log(`  Activity spread:  ${walletScore.activitySpread}/3`)\n    console.log(`  TOTAL:            ${walletScore.total}/15`)\n    console.log('========================\\n')\n\n    const profileData: CryptoWalletProfileData = {\n      chain,\n      address,\n      onChainData,\n      score: walletScore,\n      verifiedAt: new Date().toISOString(),\n    }\n\n    // Save to founder_verifications\n    await (supabase.from('founder_verifications') as ReturnType<typeof supabase.from>)\n      .upsert({\n        founder_id: founder.id,\n        verification_type: 'crypto_wallet',\n        status: 'verified',\n        verified_at: new Date().toISOString(),\n        metadata: profileData as unknown as Record<string, unknown>,\n      }, { onConflict: 'founder_id,verification_type' })\n\n    // Recalculate trust score\n    try {\n      await fetch(new URL('/api/trust-score/calculate', request.url).toString(), {\n        method: 'PUT',\n        headers: {\n          'Content-Type': 'application/json',\n          cookie: request.headers.get('cookie') || '',\n        },\n        body: JSON.stringify({}),\n      })\n    } catch {\n      // Non-critical — score will be recalculated on next page load\n    }\n\n    return NextResponse.json({\n      verified: true,\n      chain,\n      address,\n      score: walletScore,\n      onChainData,\n    })\n  } catch {\n    return NextResponse.json({ error: 'Verification failed' }, { status: 500 })\n  }\n}\n"],"names":[],"mappings":"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"}}]
}