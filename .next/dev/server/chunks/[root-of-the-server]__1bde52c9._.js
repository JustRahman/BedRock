module.exports = [
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/node:net [external] (node:net, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:net", () => require("node:net"));

module.exports = mod;
}),
"[externals]/node:stream [external] (node:stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:stream", () => require("node:stream"));

module.exports = mod;
}),
"[externals]/buffer [external] (buffer, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}),
"[externals]/string_decoder [external] (string_decoder, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("string_decoder", () => require("string_decoder"));

module.exports = mod;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[externals]/node:assert [external] (node:assert, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:assert", () => require("node:assert"));

module.exports = mod;
}),
"[externals]/node:http [external] (node:http, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:http", () => require("node:http"));

module.exports = mod;
}),
"[externals]/node:querystring [external] (node:querystring, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:querystring", () => require("node:querystring"));

module.exports = mod;
}),
"[externals]/node:events [external] (node:events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:events", () => require("node:events"));

module.exports = mod;
}),
"[externals]/node:diagnostics_channel [external] (node:diagnostics_channel, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:diagnostics_channel", () => require("node:diagnostics_channel"));

module.exports = mod;
}),
"[externals]/node:util [external] (node:util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:util", () => require("node:util"));

module.exports = mod;
}),
"[externals]/node:tls [external] (node:tls, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:tls", () => require("node:tls"));

module.exports = mod;
}),
"[externals]/node:buffer [external] (node:buffer, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:buffer", () => require("node:buffer"));

module.exports = mod;
}),
"[externals]/node:zlib [external] (node:zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:zlib", () => require("node:zlib"));

module.exports = mod;
}),
"[externals]/node:perf_hooks [external] (node:perf_hooks, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:perf_hooks", () => require("node:perf_hooks"));

module.exports = mod;
}),
"[externals]/node:util/types [external] (node:util/types, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:util/types", () => require("node:util/types"));

module.exports = mod;
}),
"[externals]/node:crypto [external] (node:crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:crypto", () => require("node:crypto"));

module.exports = mod;
}),
"[externals]/node:worker_threads [external] (node:worker_threads, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:worker_threads", () => require("node:worker_threads"));

module.exports = mod;
}),
"[externals]/node:http2 [external] (node:http2, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:http2", () => require("node:http2"));

module.exports = mod;
}),
"[externals]/node:async_hooks [external] (node:async_hooks, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:async_hooks", () => require("node:async_hooks"));

module.exports = mod;
}),
"[externals]/node:console [external] (node:console, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:console", () => require("node:console"));

module.exports = mod;
}),
"[externals]/node:fs/promises [external] (node:fs/promises, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:fs/promises", () => require("node:fs/promises"));

module.exports = mod;
}),
"[externals]/node:path [external] (node:path, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:path", () => require("node:path"));

module.exports = mod;
}),
"[externals]/node:timers [external] (node:timers, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:timers", () => require("node:timers"));

module.exports = mod;
}),
"[externals]/node:dns [external] (node:dns, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:dns", () => require("node:dns"));

module.exports = mod;
}),
"[project]/src/lib/digital-presence-verification.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "verifyAppStore",
    ()=>verifyAppStore,
    "verifyDomain",
    ()=>verifyDomain,
    "verifyInstagram",
    ()=>verifyInstagram,
    "verifyTwitter",
    ()=>verifyTwitter
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$whoiser$2f$dist$2f$whoiser$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/whoiser/dist/whoiser.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cheerio$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/cheerio/dist/esm/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cheerio$2f$dist$2f$esm$2f$load$2d$parse$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cheerio/dist/esm/load-parse.js [app-route] (ecmascript)");
;
;
async function verifyDomain(url) {
    let hostname;
    try {
        const parsed = new URL(url.startsWith('http') ? url : `https://${url}`);
        hostname = parsed.hostname;
    } catch  {
        return {
            isLive: false,
            hasSSL: false,
            error: 'Invalid URL format'
        };
    }
    const result = {
        isLive: false,
        hasSSL: false
    };
    // WHOIS lookup
    try {
        const whoisData = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$whoiser$2f$dist$2f$whoiser$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["whoisDomain"])(hostname, {
            follow: 1,
            timeout: 5000
        });
        // whoiser returns an object keyed by registrar server
        const firstKey = Object.keys(whoisData)[0];
        const record = firstKey ? whoisData[firstKey] : null;
        if (record) {
            const createdRaw = record['Created Date'] || record['Creation Date'] || record['created'] || record['Registration Date'];
            const expiryRaw = record['Expiry Date'] || record['Registry Expiry Date'] || record['expires'] || record['Expiration Date'];
            const registrarRaw = record['Registrar'] || record['registrar'];
            if (createdRaw) {
                const createdStr = Array.isArray(createdRaw) ? String(createdRaw[0]) : String(createdRaw);
                const createdDate = new Date(createdStr);
                if (!isNaN(createdDate.getTime())) {
                    result.createdDate = createdDate.toISOString().split('T')[0];
                    const ageMs = Date.now() - createdDate.getTime();
                    result.domainAge = Math.round(ageMs / (1000 * 60 * 60 * 24 * 365) * 10) / 10;
                }
            }
            if (expiryRaw) {
                const expiryStr = Array.isArray(expiryRaw) ? String(expiryRaw[0]) : String(expiryRaw);
                const expiryDate = new Date(expiryStr);
                if (!isNaN(expiryDate.getTime())) {
                    result.expiryDate = expiryDate.toISOString().split('T')[0];
                }
            }
            if (registrarRaw) {
                result.registrar = Array.isArray(registrarRaw) ? String(registrarRaw[0]) : String(registrarRaw);
            }
        }
    } catch  {
    // WHOIS may fail for some TLDs — continue with website fetch
    }
    // Website content fetch
    try {
        const fetchUrl = url.startsWith('http') ? url : `https://${url}`;
        result.hasSSL = fetchUrl.startsWith('https://');
        const controller = new AbortController();
        const timeout = setTimeout(()=>controller.abort(), 5000);
        const response = await fetch(fetchUrl, {
            signal: controller.signal,
            redirect: 'follow',
            headers: {
                'User-Agent': 'BedRock-Verifier/1.0',
                'Accept': 'text/html'
            }
        });
        clearTimeout(timeout);
        if (response.ok) {
            result.isLive = true;
            result.hasSSL = response.url.startsWith('https://');
            const html = await response.text();
            const $ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cheerio$2f$dist$2f$esm$2f$load$2d$parse$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["load"](html);
            result.title = $('title').first().text().trim() || undefined;
            result.description = $('meta[name="description"]').attr('content')?.trim() || $('meta[property="og:description"]').attr('content')?.trim() || undefined;
            result.ogImage = $('meta[property="og:image"]').attr('content')?.trim() || undefined;
        }
    } catch  {
    // Site unreachable — isLive stays false
    }
    if (!result.isLive && !result.createdDate) {
        result.error = 'Could not verify domain — site unreachable and WHOIS lookup failed';
    }
    return result;
}
function verifyTwitter(handle) {
    // Normalize: strip @ and URL prefixes
    let normalized = handle.trim();
    normalized = normalized.replace(/^https?:\/\/(www\.)?(twitter|x)\.com\//, '');
    normalized = normalized.replace(/^@/, '');
    normalized = normalized.split('/')[0]; // remove trailing paths
    normalized = normalized.split('?')[0]; // remove query params
    const valid = /^[a-zA-Z0-9_]{1,15}$/.test(normalized);
    return {
        handle: normalized,
        valid,
        profileUrl: `https://x.com/${normalized}`
    };
}
function verifyInstagram(handle) {
    let normalized = handle.trim();
    normalized = normalized.replace(/^https?:\/\/(www\.)?instagram\.com\//, '');
    normalized = normalized.replace(/^@/, '');
    normalized = normalized.split('/')[0];
    normalized = normalized.split('?')[0];
    const valid = /^[a-zA-Z0-9_.]{1,30}$/.test(normalized);
    return {
        handle: normalized,
        valid,
        profileUrl: `https://instagram.com/${normalized}`
    };
}
async function verifyAppStore(url) {
    // Extract app ID from URL like apps.apple.com/.../id1234567890
    const match = url.match(/id(\d+)/);
    if (!match) {
        return {
            error: 'Could not find app ID in URL. Use a link like apps.apple.com/app/name/id123456789'
        };
    }
    const appId = match[1];
    try {
        const controller = new AbortController();
        const timeout = setTimeout(()=>controller.abort(), 5000);
        const response = await fetch(`https://itunes.apple.com/lookup?id=${appId}&country=us`, {
            signal: controller.signal
        });
        clearTimeout(timeout);
        if (!response.ok) {
            return {
                error: 'App Store lookup failed'
            };
        }
        const data = await response.json();
        if (!data.results || data.results.length === 0) {
            return {
                error: 'App not found in the App Store'
            };
        }
        const app = data.results[0];
        return {
            appName: app.trackName,
            developer: app.artistName,
            rating: app.averageUserRating ? Math.round(app.averageUserRating * 10) / 10 : undefined,
            ratingCount: app.userRatingCount,
            price: app.formattedPrice || (app.price === 0 ? 'Free' : `$${app.price}`),
            genre: app.primaryGenreName,
            releaseDate: app.releaseDate?.split('T')[0],
            iconUrl: app.artworkUrl100
        };
    } catch  {
        return {
            error: 'Could not reach App Store. Please try again.'
        };
    }
}
}),
"[project]/src/app/api/verify/digital-presence/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "POST",
    ()=>POST
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$digital$2d$presence$2d$verification$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/digital-presence-verification.ts [app-route] (ecmascript)");
;
;
async function POST(request) {
    try {
        const { type, value } = await request.json();
        if (!type || !value || typeof value !== 'string') {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                success: false,
                error: 'Missing type or value'
            }, {
                status: 400
            });
        }
        switch(type){
            case 'domain':
                {
                    const data = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$digital$2d$presence$2d$verification$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["verifyDomain"])(value);
                    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                        success: !data.error,
                        data
                    });
                }
            case 'twitter':
                {
                    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$digital$2d$presence$2d$verification$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["verifyTwitter"])(value);
                    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                        success: data.valid,
                        data
                    });
                }
            case 'instagram':
                {
                    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$digital$2d$presence$2d$verification$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["verifyInstagram"])(value);
                    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                        success: data.valid,
                        data
                    });
                }
            case 'appstore':
                {
                    const data = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$digital$2d$presence$2d$verification$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["verifyAppStore"])(value);
                    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                        success: !data.error,
                        data
                    });
                }
            default:
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    success: false,
                    error: `Unknown verification type: ${type}`
                }, {
                    status: 400
                });
        }
    } catch  {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: false,
            error: 'Verification failed'
        }, {
            status: 500
        });
    }
}
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__1bde52c9._.js.map