{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 130, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahmanbazarov/Data/programming/BedRock/src/lib/crypto/verify-signature.ts"],"sourcesContent":["import { ethers } from 'ethers'\nimport nacl from 'tweetnacl'\nimport bs58 from 'bs58'\nimport type { ChainId, WalletVerificationRequest } from './types'\n\nexport function generateChallengeMessage(address: string): string {\n  const nonce = Math.random().toString(36).substring(2, 15)\n  const timestamp = Date.now()\n  return `BedRock Wallet Verification\\n\\nAddress: ${address}\\nNonce: ${nonce}\\nTimestamp: ${timestamp}\\n\\nSign this message to verify wallet ownership.`\n}\n\nexport function verifyWalletSignature(req: WalletVerificationRequest): { valid: boolean; recoveredAddress?: string } {\n  try {\n    if (req.chain === 'solana') {\n      return verifySolana(req)\n    } else if (req.chain === 'tron') {\n      return verifyTron(req)\n    } else {\n      return verifyEvm(req)\n    }\n  } catch {\n    return { valid: false }\n  }\n}\n\nfunction verifyEvm(req: WalletVerificationRequest): { valid: boolean; recoveredAddress?: string } {\n  const recovered = ethers.verifyMessage(req.message, req.signature)\n  const valid = recovered.toLowerCase() === req.address.toLowerCase()\n  return { valid, recoveredAddress: recovered }\n}\n\nfunction verifySolana(req: WalletVerificationRequest): { valid: boolean; recoveredAddress?: string } {\n  const messageBytes = new TextEncoder().encode(req.message)\n  const signatureBytes = bs58.decode(req.signature)\n  const publicKeyBytes = bs58.decode(req.address)\n\n  const valid = nacl.sign.detached.verify(messageBytes, signatureBytes, publicKeyBytes)\n  return { valid, recoveredAddress: req.address }\n}\n\nfunction verifyTron(req: WalletVerificationRequest): { valid: boolean; recoveredAddress?: string } {\n  // Tron uses the same ECDSA as Ethereum, but with a different address format\n  // TronLink signs with personal_sign compatible format\n  const recovered = ethers.verifyMessage(req.message, req.signature)\n\n  // Convert Ethereum address to Tron format for comparison\n  // Tron addresses start with 'T' and use base58check with 0x41 prefix\n  // For verification, we compare the hex portion\n  const evmHex = recovered.toLowerCase().replace('0x', '')\n  const tronHex = tronAddressToHex(req.address).toLowerCase()\n\n  const valid = evmHex === tronHex\n  return { valid, recoveredAddress: req.address }\n}\n\nfunction tronAddressToHex(tronAddress: string): string {\n  if (tronAddress.startsWith('0x') || tronAddress.startsWith('0X')) {\n    return tronAddress.replace('0x', '').replace('0X', '')\n  }\n  // Base58 decode Tron address -> strip 0x41 prefix and 4-byte checksum\n  try {\n    const decoded = bs58.decode(tronAddress)\n    // Tron address: 1 byte prefix (0x41) + 20 bytes address + 4 bytes checksum\n    const addressBytes = decoded.slice(1, 21)\n    return Buffer.from(addressBytes).toString('hex')\n  } catch {\n    return ''\n  }\n}\n\nexport function isEvmChain(chain: ChainId): boolean {\n  return chain === 'ethereum' || chain === 'base' || chain === 'polygon'\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;;;;AAGO,SAAS,yBAAyB,OAAe;IACtD,MAAM,QAAQ,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,SAAS,CAAC,GAAG;IACtD,MAAM,YAAY,KAAK,GAAG;IAC1B,OAAO,CAAC,wCAAwC,EAAE,QAAQ,SAAS,EAAE,MAAM,aAAa,EAAE,UAAU,iDAAiD,CAAC;AACxJ;AAEO,SAAS,sBAAsB,GAA8B;IAClE,IAAI;QACF,IAAI,IAAI,KAAK,KAAK,UAAU;YAC1B,OAAO,aAAa;QACtB,OAAO,IAAI,IAAI,KAAK,KAAK,QAAQ;YAC/B,OAAO,WAAW;QACpB,OAAO;YACL,OAAO,UAAU;QACnB;IACF,EAAE,OAAM;QACN,OAAO;YAAE,OAAO;QAAM;IACxB;AACF;AAEA,SAAS,UAAU,GAA8B;IAC/C,MAAM,YAAY,4LAAM,CAAC,aAAa,CAAC,IAAI,OAAO,EAAE,IAAI,SAAS;IACjE,MAAM,QAAQ,UAAU,WAAW,OAAO,IAAI,OAAO,CAAC,WAAW;IACjE,OAAO;QAAE;QAAO,kBAAkB;IAAU;AAC9C;AAEA,SAAS,aAAa,GAA8B;IAClD,MAAM,eAAe,IAAI,cAAc,MAAM,CAAC,IAAI,OAAO;IACzD,MAAM,iBAAiB,wJAAI,CAAC,MAAM,CAAC,IAAI,SAAS;IAChD,MAAM,iBAAiB,wJAAI,CAAC,MAAM,CAAC,IAAI,OAAO;IAE9C,MAAM,QAAQ,sJAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,cAAc,gBAAgB;IACtE,OAAO;QAAE;QAAO,kBAAkB,IAAI,OAAO;IAAC;AAChD;AAEA,SAAS,WAAW,GAA8B;IAChD,4EAA4E;IAC5E,sDAAsD;IACtD,MAAM,YAAY,4LAAM,CAAC,aAAa,CAAC,IAAI,OAAO,EAAE,IAAI,SAAS;IAEjE,yDAAyD;IACzD,qEAAqE;IACrE,+CAA+C;IAC/C,MAAM,SAAS,UAAU,WAAW,GAAG,OAAO,CAAC,MAAM;IACrD,MAAM,UAAU,iBAAiB,IAAI,OAAO,EAAE,WAAW;IAEzD,MAAM,QAAQ,WAAW;IACzB,OAAO;QAAE;QAAO,kBAAkB,IAAI,OAAO;IAAC;AAChD;AAEA,SAAS,iBAAiB,WAAmB;IAC3C,IAAI,YAAY,UAAU,CAAC,SAAS,YAAY,UAAU,CAAC,OAAO;QAChE,OAAO,YAAY,OAAO,CAAC,MAAM,IAAI,OAAO,CAAC,MAAM;IACrD;IACA,sEAAsE;IACtE,IAAI;QACF,MAAM,UAAU,wJAAI,CAAC,MAAM,CAAC;QAC5B,2EAA2E;QAC3E,MAAM,eAAe,QAAQ,KAAK,CAAC,GAAG;QACtC,OAAO,OAAO,IAAI,CAAC,cAAc,QAAQ,CAAC;IAC5C,EAAE,OAAM;QACN,OAAO;IACT;AACF;AAEO,SAAS,WAAW,KAAc;IACvC,OAAO,UAAU,cAAc,UAAU,UAAU,UAAU;AAC/D"}},
    {"offset": {"line": 218, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahmanbazarov/Data/programming/BedRock/src/lib/crypto/challenge-cache.ts"],"sourcesContent":["// In-memory challenge cache (address -> { message, expiresAt })\nconst challengeCache = new Map<string, { message: string; expiresAt: number }>()\n\nexport const CHALLENGE_TTL_MS = 5 * 60 * 1000 // 5 minutes\n\nexport function setChallengeMessage(address: string, message: string): void {\n  challengeCache.set(address.toLowerCase(), {\n    message,\n    expiresAt: Date.now() + CHALLENGE_TTL_MS,\n  })\n\n  // Cleanup expired entries periodically\n  if (challengeCache.size > 1000) {\n    const now = Date.now()\n    for (const [key, val] of challengeCache) {\n      if (val.expiresAt < now) challengeCache.delete(key)\n    }\n  }\n}\n\nexport function getChallengeMessage(address: string): { message: string; expiresAt: number } | undefined {\n  return challengeCache.get(address.toLowerCase())\n}\n\nexport function deleteChallengeMessage(address: string): void {\n  challengeCache.delete(address.toLowerCase())\n}\n"],"names":[],"mappings":";;;;;;;;;;AAAA,gEAAgE;AAChE,MAAM,iBAAiB,IAAI;AAEpB,MAAM,mBAAmB,IAAI,KAAK,KAAK,YAAY;;AAEnD,SAAS,oBAAoB,OAAe,EAAE,OAAe;IAClE,eAAe,GAAG,CAAC,QAAQ,WAAW,IAAI;QACxC;QACA,WAAW,KAAK,GAAG,KAAK;IAC1B;IAEA,uCAAuC;IACvC,IAAI,eAAe,IAAI,GAAG,MAAM;QAC9B,MAAM,MAAM,KAAK,GAAG;QACpB,KAAK,MAAM,CAAC,KAAK,IAAI,IAAI,eAAgB;YACvC,IAAI,IAAI,SAAS,GAAG,KAAK,eAAe,MAAM,CAAC;QACjD;IACF;AACF;AAEO,SAAS,oBAAoB,OAAe;IACjD,OAAO,eAAe,GAAG,CAAC,QAAQ,WAAW;AAC/C;AAEO,SAAS,uBAAuB,OAAe;IACpD,eAAe,MAAM,CAAC,QAAQ,WAAW;AAC3C"}},
    {"offset": {"line": 255, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahmanbazarov/Data/programming/BedRock/src/lib/rate-limit.ts"],"sourcesContent":["const rateLimitMap = new Map<string, { count: number; resetAt: number }>()\n\n// Cleanup stale entries every 5 minutes\nsetInterval(() => {\n  const now = Date.now()\n  for (const [key, entry] of rateLimitMap) {\n    if (now > entry.resetAt) {\n      rateLimitMap.delete(key)\n    }\n  }\n}, 5 * 60_000)\n\nexport function checkRateLimit(\n  key: string,\n  maxRequests: number = 10,\n  windowMs: number = 60_000\n): { allowed: boolean; remaining: number; resetIn: number } {\n  const now = Date.now()\n  const entry = rateLimitMap.get(key)\n\n  if (!entry || now > entry.resetAt) {\n    rateLimitMap.set(key, { count: 1, resetAt: now + windowMs })\n    return { allowed: true, remaining: maxRequests - 1, resetIn: windowMs }\n  }\n\n  if (entry.count >= maxRequests) {\n    return { allowed: false, remaining: 0, resetIn: entry.resetAt - now }\n  }\n\n  entry.count++\n  return { allowed: true, remaining: maxRequests - entry.count, resetIn: entry.resetAt - now }\n}\n\nexport function getClientIp(request: Request): string {\n  const forwarded = request.headers.get('x-forwarded-for')\n  const realIp = request.headers.get('x-real-ip')\n  return forwarded?.split(',')[0]?.trim() || realIp || 'unknown'\n}\n"],"names":[],"mappings":";;;;;;AAAA,MAAM,eAAe,IAAI;AAEzB,wCAAwC;AACxC,YAAY;IACV,MAAM,MAAM,KAAK,GAAG;IACpB,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,aAAc;QACvC,IAAI,MAAM,MAAM,OAAO,EAAE;YACvB,aAAa,MAAM,CAAC;QACtB;IACF;AACF,GAAG,IAAI;AAEA,SAAS,eACd,GAAW,EACX,cAAsB,EAAE,EACxB,WAAmB,MAAM;IAEzB,MAAM,MAAM,KAAK,GAAG;IACpB,MAAM,QAAQ,aAAa,GAAG,CAAC;IAE/B,IAAI,CAAC,SAAS,MAAM,MAAM,OAAO,EAAE;QACjC,aAAa,GAAG,CAAC,KAAK;YAAE,OAAO;YAAG,SAAS,MAAM;QAAS;QAC1D,OAAO;YAAE,SAAS;YAAM,WAAW,cAAc;YAAG,SAAS;QAAS;IACxE;IAEA,IAAI,MAAM,KAAK,IAAI,aAAa;QAC9B,OAAO;YAAE,SAAS;YAAO,WAAW;YAAG,SAAS,MAAM,OAAO,GAAG;QAAI;IACtE;IAEA,MAAM,KAAK;IACX,OAAO;QAAE,SAAS;QAAM,WAAW,cAAc,MAAM,KAAK;QAAE,SAAS,MAAM,OAAO,GAAG;IAAI;AAC7F;AAEO,SAAS,YAAY,OAAgB;IAC1C,MAAM,YAAY,QAAQ,OAAO,CAAC,GAAG,CAAC;IACtC,MAAM,SAAS,QAAQ,OAAO,CAAC,GAAG,CAAC;IACnC,OAAO,WAAW,MAAM,IAAI,CAAC,EAAE,EAAE,UAAU,UAAU;AACvD"}},
    {"offset": {"line": 308, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahmanbazarov/Data/programming/BedRock/src/app/api/crypto/challenge/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server'\nimport { generateChallengeMessage } from '@/lib/crypto/verify-signature'\nimport { setChallengeMessage } from '@/lib/crypto/challenge-cache'\nimport { checkRateLimit, getClientIp } from '@/lib/rate-limit'\n\nexport async function POST(request: Request) {\n  const ip = getClientIp(request)\n  const { allowed, resetIn } = checkRateLimit(`crypto-challenge:${ip}`, 20, 60_000)\n  if (!allowed) {\n    return NextResponse.json(\n      { error: 'Too many requests' },\n      { status: 429, headers: { 'Retry-After': String(Math.ceil(resetIn / 1000)) } }\n    )\n  }\n\n  try {\n    const { address } = await request.json()\n    if (!address || typeof address !== 'string') {\n      return NextResponse.json({ error: 'Address is required' }, { status: 400 })\n    }\n\n    const message = generateChallengeMessage(address)\n    setChallengeMessage(address, message)\n\n    return NextResponse.json({ message })\n  } catch {\n    return NextResponse.json({ error: 'Failed to generate challenge' }, { status: 500 })\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAEO,eAAe,KAAK,OAAgB;IACzC,MAAM,KAAK,IAAA,4IAAW,EAAC;IACvB,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,GAAG,IAAA,+IAAc,EAAC,CAAC,iBAAiB,EAAE,IAAI,EAAE,IAAI;IAC1E,IAAI,CAAC,SAAS;QACZ,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAoB,GAC7B;YAAE,QAAQ;YAAK,SAAS;gBAAE,eAAe,OAAO,KAAK,IAAI,CAAC,UAAU;YAAO;QAAE;IAEjF;IAEA,IAAI;QACF,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,QAAQ,IAAI;QACtC,IAAI,CAAC,WAAW,OAAO,YAAY,UAAU;YAC3C,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAsB,GAAG;gBAAE,QAAQ;YAAI;QAC3E;QAEA,MAAM,UAAU,IAAA,yKAAwB,EAAC;QACzC,IAAA,mKAAmB,EAAC,SAAS;QAE7B,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE;QAAQ;IACrC,EAAE,OAAM;QACN,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAA+B,GAAG;YAAE,QAAQ;QAAI;IACpF;AACF"}}]
}