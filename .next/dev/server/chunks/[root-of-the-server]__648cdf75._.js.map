{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahmanbazarov/Data/programming/BedRock/src/lib/oauth/utils.ts"],"sourcesContent":["import { createHmac, randomBytes } from 'crypto'\nimport { cookies } from 'next/headers'\n\nconst STATE_COOKIE_NAME = 'oauth_state'\nconst STATE_EXPIRY_MS = 15 * 60 * 1000 // 15 minutes\n\nfunction getSecret(): string {\n  const secret = process.env.OAUTH_STATE_SECRET\n  if (!secret) throw new Error('OAUTH_STATE_SECRET is not set')\n  return secret\n}\n\nfunction sign(payload: string): string {\n  return createHmac('sha256', getSecret()).update(payload).digest('hex')\n}\n\nexport function generateStateToken(provider: string, returnStep: number): string {\n  const nonce = randomBytes(16).toString('hex')\n  const timestamp = Date.now().toString()\n  const payload = `${provider}:${returnStep}:${timestamp}:${nonce}`\n  const signature = sign(payload)\n  return `${payload}:${signature}`\n}\n\nexport async function setStateCookie(state: string): Promise<void> {\n  const cookieStore = await cookies()\n  cookieStore.set(STATE_COOKIE_NAME, state, {\n    httpOnly: true,\n    secure: process.env.NODE_ENV === 'production',\n    sameSite: 'lax',\n    maxAge: 900, // 15 minutes\n    path: '/',\n  })\n}\n\nexport async function verifyStateToken(state: string): Promise<{ provider: string; returnStep: number } | null> {\n  const cookieStore = await cookies()\n  const cookieValue = cookieStore.get(STATE_COOKIE_NAME)?.value\n\n  if (!cookieValue || cookieValue !== state) return null\n\n  const parts = state.split(':')\n  if (parts.length !== 5) return null\n\n  const [provider, returnStep, timestamp, nonce, signature] = parts\n  const payload = `${provider}:${returnStep}:${timestamp}:${nonce}`\n  const expectedSignature = sign(payload)\n\n  if (signature !== expectedSignature) return null\n\n  const age = Date.now() - parseInt(timestamp, 10)\n  if (age > STATE_EXPIRY_MS) return null\n\n  // Clear the cookie after verification\n  cookieStore.delete(STATE_COOKIE_NAME)\n\n  return { provider, returnStep: parseInt(returnStep, 10) }\n}\n\n// Simple in-memory cache with TTL for storing OAuth data between callback and retrieval\nconst cache = new Map<string, { data: unknown; expiresAt: number }>()\n\nconst CACHE_TTL_MS = 15 * 60 * 1000 // 15 minutes\n\nexport function cacheSet(key: string, data: unknown): void {\n  cache.set(key, { data, expiresAt: Date.now() + CACHE_TTL_MS })\n}\n\nexport function cacheGet(key: string): unknown | null {\n  const entry = cache.get(key)\n  if (!entry) return null\n  if (Date.now() > entry.expiresAt) {\n    cache.delete(key)\n    return null\n  }\n  return entry.data\n}\n\nexport function cacheDelete(key: string): void {\n  cache.delete(key)\n}\n\nexport function generateSessionId(): string {\n  return randomBytes(32).toString('hex')\n}\n\nexport function getAppUrl(): string {\n  return process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;;;AAEA,MAAM,oBAAoB;AAC1B,MAAM,kBAAkB,KAAK,KAAK,KAAK,aAAa;;AAEpD,SAAS;IACP,MAAM,SAAS,QAAQ,GAAG,CAAC,kBAAkB;IAC7C,IAAI,CAAC,QAAQ,MAAM,IAAI,MAAM;IAC7B,OAAO;AACT;AAEA,SAAS,KAAK,OAAe;IAC3B,OAAO,IAAA,mHAAU,EAAC,UAAU,aAAa,MAAM,CAAC,SAAS,MAAM,CAAC;AAClE;AAEO,SAAS,mBAAmB,QAAgB,EAAE,UAAkB;IACrE,MAAM,QAAQ,IAAA,oHAAW,EAAC,IAAI,QAAQ,CAAC;IACvC,MAAM,YAAY,KAAK,GAAG,GAAG,QAAQ;IACrC,MAAM,UAAU,GAAG,SAAS,CAAC,EAAE,WAAW,CAAC,EAAE,UAAU,CAAC,EAAE,OAAO;IACjE,MAAM,YAAY,KAAK;IACvB,OAAO,GAAG,QAAQ,CAAC,EAAE,WAAW;AAClC;AAEO,eAAe,eAAe,KAAa;IAChD,MAAM,cAAc,MAAM,IAAA,4IAAO;IACjC,YAAY,GAAG,CAAC,mBAAmB,OAAO;QACxC,UAAU;QACV,QAAQ,oDAAyB;QACjC,UAAU;QACV,QAAQ;QACR,MAAM;IACR;AACF;AAEO,eAAe,iBAAiB,KAAa;IAClD,MAAM,cAAc,MAAM,IAAA,4IAAO;IACjC,MAAM,cAAc,YAAY,GAAG,CAAC,oBAAoB;IAExD,IAAI,CAAC,eAAe,gBAAgB,OAAO,OAAO;IAElD,MAAM,QAAQ,MAAM,KAAK,CAAC;IAC1B,IAAI,MAAM,MAAM,KAAK,GAAG,OAAO;IAE/B,MAAM,CAAC,UAAU,YAAY,WAAW,OAAO,UAAU,GAAG;IAC5D,MAAM,UAAU,GAAG,SAAS,CAAC,EAAE,WAAW,CAAC,EAAE,UAAU,CAAC,EAAE,OAAO;IACjE,MAAM,oBAAoB,KAAK;IAE/B,IAAI,cAAc,mBAAmB,OAAO;IAE5C,MAAM,MAAM,KAAK,GAAG,KAAK,SAAS,WAAW;IAC7C,IAAI,MAAM,iBAAiB,OAAO;IAElC,sCAAsC;IACtC,YAAY,MAAM,CAAC;IAEnB,OAAO;QAAE;QAAU,YAAY,SAAS,YAAY;IAAI;AAC1D;AAEA,wFAAwF;AACxF,MAAM,QAAQ,IAAI;AAElB,MAAM,eAAe,KAAK,KAAK,KAAK,aAAa;;AAE1C,SAAS,SAAS,GAAW,EAAE,IAAa;IACjD,MAAM,GAAG,CAAC,KAAK;QAAE;QAAM,WAAW,KAAK,GAAG,KAAK;IAAa;AAC9D;AAEO,SAAS,SAAS,GAAW;IAClC,MAAM,QAAQ,MAAM,GAAG,CAAC;IACxB,IAAI,CAAC,OAAO,OAAO;IACnB,IAAI,KAAK,GAAG,KAAK,MAAM,SAAS,EAAE;QAChC,MAAM,MAAM,CAAC;QACb,OAAO;IACT;IACA,OAAO,MAAM,IAAI;AACnB;AAEO,SAAS,YAAY,GAAW;IACrC,MAAM,MAAM,CAAC;AACf;AAEO,SAAS;IACd,OAAO,IAAA,oHAAW,EAAC,IAAI,QAAQ,CAAC;AAClC;AAEO,SAAS;IACd,OAAO,6DAAmC;AAC5C"}},
    {"offset": {"line": 153, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahmanbazarov/Data/programming/BedRock/src/lib/oauth/linkedin.ts"],"sourcesContent":["import { getAppUrl } from './utils'\n\nexport interface LinkedInProfileData {\n  name: string\n  email: string\n  picture: string | null\n  sub: string\n  verified: boolean\n}\n\nexport function getLinkedInAuthUrl(state: string): string {\n  const clientId = process.env.LINKEDIN_CLIENT_ID\n  if (!clientId) throw new Error('LINKEDIN_CLIENT_ID is not set')\n\n  const params = new URLSearchParams({\n    response_type: 'code',\n    client_id: clientId,\n    scope: 'openid profile email',\n    state,\n    redirect_uri: `${getAppUrl()}/api/oauth/linkedin/callback`,\n  })\n\n  return `https://www.linkedin.com/oauth/v2/authorization?${params.toString()}`\n}\n\nexport async function exchangeLinkedInCode(code: string): Promise<string> {\n  const params = new URLSearchParams({\n    grant_type: 'authorization_code',\n    code,\n    client_id: process.env.LINKEDIN_CLIENT_ID!,\n    client_secret: process.env.LINKEDIN_CLIENT_SECRET!,\n    redirect_uri: `${getAppUrl()}/api/oauth/linkedin/callback`,\n  })\n\n  const response = await fetch('https://www.linkedin.com/oauth/v2/accessToken', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n    body: params.toString(),\n  })\n\n  const data = await response.json()\n  if (data.error) {\n    throw new Error(`LinkedIn OAuth error: ${data.error_description || data.error}`)\n  }\n\n  return data.access_token\n}\n\nexport async function fetchLinkedInProfile(token: string): Promise<LinkedInProfileData> {\n  const response = await fetch('https://api.linkedin.com/v2/userinfo', {\n    headers: { Authorization: `Bearer ${token}` },\n  })\n\n  if (!response.ok) {\n    throw new Error(`LinkedIn API error: ${response.status}`)\n  }\n\n  const data = await response.json()\n\n  return {\n    name: data.name || `${data.given_name || ''} ${data.family_name || ''}`.trim(),\n    email: data.email || '',\n    picture: data.picture || null,\n    sub: data.sub,\n    verified: true,\n  }\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;;AAUO,SAAS,mBAAmB,KAAa;IAC9C,MAAM,WAAW,QAAQ,GAAG,CAAC,kBAAkB;IAC/C,IAAI,CAAC,UAAU,MAAM,IAAI,MAAM;IAE/B,MAAM,SAAS,IAAI,gBAAgB;QACjC,eAAe;QACf,WAAW;QACX,OAAO;QACP;QACA,cAAc,GAAG,IAAA,2IAAS,IAAG,4BAA4B,CAAC;IAC5D;IAEA,OAAO,CAAC,gDAAgD,EAAE,OAAO,QAAQ,IAAI;AAC/E;AAEO,eAAe,qBAAqB,IAAY;IACrD,MAAM,SAAS,IAAI,gBAAgB;QACjC,YAAY;QACZ;QACA,WAAW,QAAQ,GAAG,CAAC,kBAAkB;QACzC,eAAe,QAAQ,GAAG,CAAC,sBAAsB;QACjD,cAAc,GAAG,IAAA,2IAAS,IAAG,4BAA4B,CAAC;IAC5D;IAEA,MAAM,WAAW,MAAM,MAAM,iDAAiD;QAC5E,QAAQ;QACR,SAAS;YAAE,gBAAgB;QAAoC;QAC/D,MAAM,OAAO,QAAQ;IACvB;IAEA,MAAM,OAAO,MAAM,SAAS,IAAI;IAChC,IAAI,KAAK,KAAK,EAAE;QACd,MAAM,IAAI,MAAM,CAAC,sBAAsB,EAAE,KAAK,iBAAiB,IAAI,KAAK,KAAK,EAAE;IACjF;IAEA,OAAO,KAAK,YAAY;AAC1B;AAEO,eAAe,qBAAqB,KAAa;IACtD,MAAM,WAAW,MAAM,MAAM,wCAAwC;QACnE,SAAS;YAAE,eAAe,CAAC,OAAO,EAAE,OAAO;QAAC;IAC9C;IAEA,IAAI,CAAC,SAAS,EAAE,EAAE;QAChB,MAAM,IAAI,MAAM,CAAC,oBAAoB,EAAE,SAAS,MAAM,EAAE;IAC1D;IAEA,MAAM,OAAO,MAAM,SAAS,IAAI;IAEhC,OAAO;QACL,MAAM,KAAK,IAAI,IAAI,GAAG,KAAK,UAAU,IAAI,GAAG,CAAC,EAAE,KAAK,WAAW,IAAI,IAAI,CAAC,IAAI;QAC5E,OAAO,KAAK,KAAK,IAAI;QACrB,SAAS,KAAK,OAAO,IAAI;QACzB,KAAK,KAAK,GAAG;QACb,UAAU;IACZ;AACF"}},
    {"offset": {"line": 218, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahmanbazarov/Data/programming/BedRock/src/app/api/oauth/linkedin/connect/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server'\nimport { generateStateToken, setStateCookie } from '@/lib/oauth/utils'\nimport { getLinkedInAuthUrl } from '@/lib/oauth/linkedin'\n\nexport async function GET() {\n  try {\n    if (!process.env.LINKEDIN_CLIENT_ID || !process.env.LINKEDIN_CLIENT_SECRET) {\n      return NextResponse.json({ error: 'LinkedIn OAuth not configured' }, { status: 503 })\n    }\n\n    const state = generateStateToken('linkedin', 4)\n    await setStateCookie(state)\n    const url = getLinkedInAuthUrl(state)\n\n    return NextResponse.redirect(url)\n  } catch (error) {\n    console.error('LinkedIn connect error:', error)\n    return NextResponse.redirect(\n      `${process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'}/onboarding/oauth-success?provider=linkedin&error=${encodeURIComponent('Failed to initiate LinkedIn OAuth')}`\n    )\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEO,eAAe;IACpB,IAAI;QACF,IAAI,CAAC,QAAQ,GAAG,CAAC,kBAAkB,IAAI,CAAC,QAAQ,GAAG,CAAC,sBAAsB,EAAE;YAC1E,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAgC,GAAG;gBAAE,QAAQ;YAAI;QACrF;QAEA,MAAM,QAAQ,IAAA,oJAAkB,EAAC,YAAY;QAC7C,MAAM,IAAA,gJAAc,EAAC;QACrB,MAAM,MAAM,IAAA,uJAAkB,EAAC;QAE/B,OAAO,gJAAY,CAAC,QAAQ,CAAC;IAC/B,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,2BAA2B;QACzC,OAAO,gJAAY,CAAC,QAAQ,CAC1B,GAAG,6DAAmC,wBAAwB,kDAAkD,EAAE,mBAAmB,sCAAsC;IAE/K;AACF"}}]
}