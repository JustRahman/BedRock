{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahmanbazarov/Data/programming/BedRock/src/lib/oauth/utils.ts"],"sourcesContent":["import { createHmac, randomBytes } from 'crypto'\nimport { cookies } from 'next/headers'\n\nconst STATE_COOKIE_NAME = 'oauth_state'\nconst STATE_EXPIRY_MS = 15 * 60 * 1000 // 15 minutes\n\nfunction getSecret(): string {\n  const secret = process.env.OAUTH_STATE_SECRET\n  if (!secret) throw new Error('OAUTH_STATE_SECRET is not set')\n  return secret\n}\n\nfunction sign(payload: string): string {\n  return createHmac('sha256', getSecret()).update(payload).digest('hex')\n}\n\nexport function generateStateToken(provider: string, returnStep: number): string {\n  const nonce = randomBytes(16).toString('hex')\n  const timestamp = Date.now().toString()\n  const payload = `${provider}:${returnStep}:${timestamp}:${nonce}`\n  const signature = sign(payload)\n  return `${payload}:${signature}`\n}\n\nexport async function setStateCookie(state: string): Promise<void> {\n  const cookieStore = await cookies()\n  cookieStore.set(STATE_COOKIE_NAME, state, {\n    httpOnly: true,\n    secure: process.env.NODE_ENV === 'production',\n    sameSite: 'lax',\n    maxAge: 900, // 15 minutes\n    path: '/',\n  })\n}\n\nexport async function verifyStateToken(state: string): Promise<{ provider: string; returnStep: number } | null> {\n  const cookieStore = await cookies()\n  const cookieValue = cookieStore.get(STATE_COOKIE_NAME)?.value\n\n  if (!cookieValue || cookieValue !== state) return null\n\n  const parts = state.split(':')\n  if (parts.length !== 5) return null\n\n  const [provider, returnStep, timestamp, nonce, signature] = parts\n  const payload = `${provider}:${returnStep}:${timestamp}:${nonce}`\n  const expectedSignature = sign(payload)\n\n  if (signature !== expectedSignature) return null\n\n  const age = Date.now() - parseInt(timestamp, 10)\n  if (age > STATE_EXPIRY_MS) return null\n\n  // Clear the cookie after verification\n  cookieStore.delete(STATE_COOKIE_NAME)\n\n  return { provider, returnStep: parseInt(returnStep, 10) }\n}\n\n// Simple in-memory cache with TTL for storing OAuth data between callback and retrieval\nconst cache = new Map<string, { data: unknown; expiresAt: number }>()\n\nconst CACHE_TTL_MS = 15 * 60 * 1000 // 15 minutes\n\nexport function cacheSet(key: string, data: unknown): void {\n  cache.set(key, { data, expiresAt: Date.now() + CACHE_TTL_MS })\n}\n\nexport function cacheGet(key: string): unknown | null {\n  const entry = cache.get(key)\n  if (!entry) return null\n  if (Date.now() > entry.expiresAt) {\n    cache.delete(key)\n    return null\n  }\n  return entry.data\n}\n\nexport function cacheDelete(key: string): void {\n  cache.delete(key)\n}\n\nexport function generateSessionId(): string {\n  return randomBytes(32).toString('hex')\n}\n\nexport function getAppUrl(): string {\n  return process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;;;AAEA,MAAM,oBAAoB;AAC1B,MAAM,kBAAkB,KAAK,KAAK,KAAK,aAAa;;AAEpD,SAAS;IACP,MAAM,SAAS,QAAQ,GAAG,CAAC,kBAAkB;IAC7C,IAAI,CAAC,QAAQ,MAAM,IAAI,MAAM;IAC7B,OAAO;AACT;AAEA,SAAS,KAAK,OAAe;IAC3B,OAAO,IAAA,mHAAU,EAAC,UAAU,aAAa,MAAM,CAAC,SAAS,MAAM,CAAC;AAClE;AAEO,SAAS,mBAAmB,QAAgB,EAAE,UAAkB;IACrE,MAAM,QAAQ,IAAA,oHAAW,EAAC,IAAI,QAAQ,CAAC;IACvC,MAAM,YAAY,KAAK,GAAG,GAAG,QAAQ;IACrC,MAAM,UAAU,GAAG,SAAS,CAAC,EAAE,WAAW,CAAC,EAAE,UAAU,CAAC,EAAE,OAAO;IACjE,MAAM,YAAY,KAAK;IACvB,OAAO,GAAG,QAAQ,CAAC,EAAE,WAAW;AAClC;AAEO,eAAe,eAAe,KAAa;IAChD,MAAM,cAAc,MAAM,IAAA,4IAAO;IACjC,YAAY,GAAG,CAAC,mBAAmB,OAAO;QACxC,UAAU;QACV,QAAQ,oDAAyB;QACjC,UAAU;QACV,QAAQ;QACR,MAAM;IACR;AACF;AAEO,eAAe,iBAAiB,KAAa;IAClD,MAAM,cAAc,MAAM,IAAA,4IAAO;IACjC,MAAM,cAAc,YAAY,GAAG,CAAC,oBAAoB;IAExD,IAAI,CAAC,eAAe,gBAAgB,OAAO,OAAO;IAElD,MAAM,QAAQ,MAAM,KAAK,CAAC;IAC1B,IAAI,MAAM,MAAM,KAAK,GAAG,OAAO;IAE/B,MAAM,CAAC,UAAU,YAAY,WAAW,OAAO,UAAU,GAAG;IAC5D,MAAM,UAAU,GAAG,SAAS,CAAC,EAAE,WAAW,CAAC,EAAE,UAAU,CAAC,EAAE,OAAO;IACjE,MAAM,oBAAoB,KAAK;IAE/B,IAAI,cAAc,mBAAmB,OAAO;IAE5C,MAAM,MAAM,KAAK,GAAG,KAAK,SAAS,WAAW;IAC7C,IAAI,MAAM,iBAAiB,OAAO;IAElC,sCAAsC;IACtC,YAAY,MAAM,CAAC;IAEnB,OAAO;QAAE;QAAU,YAAY,SAAS,YAAY;IAAI;AAC1D;AAEA,wFAAwF;AACxF,MAAM,QAAQ,IAAI;AAElB,MAAM,eAAe,KAAK,KAAK,KAAK,aAAa;;AAE1C,SAAS,SAAS,GAAW,EAAE,IAAa;IACjD,MAAM,GAAG,CAAC,KAAK;QAAE;QAAM,WAAW,KAAK,GAAG,KAAK;IAAa;AAC9D;AAEO,SAAS,SAAS,GAAW;IAClC,MAAM,QAAQ,MAAM,GAAG,CAAC;IACxB,IAAI,CAAC,OAAO,OAAO;IACnB,IAAI,KAAK,GAAG,KAAK,MAAM,SAAS,EAAE;QAChC,MAAM,MAAM,CAAC;QACb,OAAO;IACT;IACA,OAAO,MAAM,IAAI;AACnB;AAEO,SAAS,YAAY,GAAW;IACrC,MAAM,MAAM,CAAC;AACf;AAEO,SAAS;IACd,OAAO,IAAA,oHAAW,EAAC,IAAI,QAAQ,CAAC;AAClC;AAEO,SAAS;IACd,OAAO,6DAAmC;AAC5C"}},
    {"offset": {"line": 177, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahmanbazarov/Data/programming/BedRock/src/lib/oauth/stripe.ts"],"sourcesContent":["import Stripe from 'stripe'\nimport { getAppUrl } from './utils'\n\nexport interface StripeProfileData {\n  monthlyRevenue: number\n  monthlyRevenueFormatted: string\n  revenueRange: string\n  accountAgeMonths: number\n  accountCreated: string\n  chargebackRate: number\n  chargebackRateCategory: string\n  totalCharges: number\n  totalDisputes: number\n}\n\nfunction getStripeClient(): Stripe {\n  const key = process.env.STRIPE_SECRET_KEY\n  if (!key) throw new Error('STRIPE_SECRET_KEY is not set')\n  return new Stripe(key)\n}\n\nexport function getStripeConnectUrl(state: string): string {\n  const clientId = process.env.STRIPE_CONNECT_CLIENT_ID\n  if (!clientId) throw new Error('STRIPE_CONNECT_CLIENT_ID is not set')\n\n  const params = new URLSearchParams({\n    response_type: 'code',\n    client_id: clientId,\n    scope: 'read_only',\n    state,\n    redirect_uri: `${getAppUrl()}/api/oauth/stripe/callback`,\n  })\n\n  return `https://connect.stripe.com/oauth/authorize?${params.toString()}`\n}\n\nexport async function exchangeStripeCode(code: string): Promise<string> {\n  const stripe = getStripeClient()\n\n  const response = await stripe.oauth.token({\n    grant_type: 'authorization_code',\n    code,\n  })\n\n  if (!response.stripe_user_id) {\n    throw new Error('Stripe OAuth: no stripe_user_id returned')\n  }\n\n  return response.stripe_user_id\n}\n\nfunction categorizeRevenue(monthly: number): string {\n  if (monthly === 0) return '0'\n  if (monthly <= 1000) return '1-1000'\n  if (monthly <= 5000) return '1000-5000'\n  if (monthly <= 10000) return '5000-10000'\n  if (monthly <= 50000) return '10000-50000'\n  return '50000+'\n}\n\nfunction categorizeChargebackRate(rate: number): string {\n  if (rate === 0) return 'none'\n  if (rate < 1) return 'low'\n  if (rate <= 3) return 'medium'\n  return 'high'\n}\n\nexport async function fetchStripeData(stripeUserId: string): Promise<StripeProfileData> {\n  const stripe = getStripeClient()\n\n  const [account, charges, disputes] = await Promise.all([\n    stripe.accounts.retrieve(stripeUserId),\n    stripe.charges.list({ limit: 100 }, { stripeAccount: stripeUserId }),\n    stripe.disputes.list({ limit: 100 }, { stripeAccount: stripeUserId }),\n  ])\n\n  // Calculate monthly revenue from charges in the last 30 days\n  const thirtyDaysAgo = Math.floor(Date.now() / 1000) - 30 * 24 * 60 * 60\n  const recentCharges = charges.data.filter(\n    (c) => c.created >= thirtyDaysAgo && c.status === 'succeeded'\n  )\n  const monthlyRevenue = recentCharges.reduce((sum, c) => sum + c.amount, 0) / 100\n\n  // Account age\n  const accountCreatedTs = account.created ?? Math.floor(Date.now() / 1000)\n  const accountCreated = new Date(accountCreatedTs * 1000).toISOString()\n  const accountAgeMonths = Math.floor(\n    (Date.now() - accountCreatedTs * 1000) / (30.44 * 24 * 60 * 60 * 1000)\n  )\n\n  // Chargeback rate\n  const totalCharges = charges.data.length\n  const totalDisputes = disputes.data.length\n  const chargebackRate = totalCharges > 0 ? (totalDisputes / totalCharges) * 100 : 0\n\n  return {\n    monthlyRevenue,\n    monthlyRevenueFormatted: `$${monthlyRevenue.toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 })}`,\n    revenueRange: categorizeRevenue(monthlyRevenue),\n    accountAgeMonths,\n    accountCreated,\n    chargebackRate: Math.round(chargebackRate * 100) / 100,\n    chargebackRateCategory: categorizeChargebackRate(chargebackRate),\n    totalCharges,\n    totalDisputes,\n  }\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;;;AAcA,SAAS;IACP,MAAM,MAAM,QAAQ,GAAG,CAAC,iBAAiB;IACzC,IAAI,CAAC,KAAK,MAAM,IAAI,MAAM;IAC1B,OAAO,IAAI,mKAAM,CAAC;AACpB;AAEO,SAAS,oBAAoB,KAAa;IAC/C,MAAM,WAAW,QAAQ,GAAG,CAAC,wBAAwB;IACrD,IAAI,CAAC,UAAU,MAAM,IAAI,MAAM;IAE/B,MAAM,SAAS,IAAI,gBAAgB;QACjC,eAAe;QACf,WAAW;QACX,OAAO;QACP;QACA,cAAc,GAAG,IAAA,2IAAS,IAAG,0BAA0B,CAAC;IAC1D;IAEA,OAAO,CAAC,2CAA2C,EAAE,OAAO,QAAQ,IAAI;AAC1E;AAEO,eAAe,mBAAmB,IAAY;IACnD,MAAM,SAAS;IAEf,MAAM,WAAW,MAAM,OAAO,KAAK,CAAC,KAAK,CAAC;QACxC,YAAY;QACZ;IACF;IAEA,IAAI,CAAC,SAAS,cAAc,EAAE;QAC5B,MAAM,IAAI,MAAM;IAClB;IAEA,OAAO,SAAS,cAAc;AAChC;AAEA,SAAS,kBAAkB,OAAe;IACxC,IAAI,YAAY,GAAG,OAAO;IAC1B,IAAI,WAAW,MAAM,OAAO;IAC5B,IAAI,WAAW,MAAM,OAAO;IAC5B,IAAI,WAAW,OAAO,OAAO;IAC7B,IAAI,WAAW,OAAO,OAAO;IAC7B,OAAO;AACT;AAEA,SAAS,yBAAyB,IAAY;IAC5C,IAAI,SAAS,GAAG,OAAO;IACvB,IAAI,OAAO,GAAG,OAAO;IACrB,IAAI,QAAQ,GAAG,OAAO;IACtB,OAAO;AACT;AAEO,eAAe,gBAAgB,YAAoB;IACxD,MAAM,SAAS;IAEf,MAAM,CAAC,SAAS,SAAS,SAAS,GAAG,MAAM,QAAQ,GAAG,CAAC;QACrD,OAAO,QAAQ,CAAC,QAAQ,CAAC;QACzB,OAAO,OAAO,CAAC,IAAI,CAAC;YAAE,OAAO;QAAI,GAAG;YAAE,eAAe;QAAa;QAClE,OAAO,QAAQ,CAAC,IAAI,CAAC;YAAE,OAAO;QAAI,GAAG;YAAE,eAAe;QAAa;KACpE;IAED,6DAA6D;IAC7D,MAAM,gBAAgB,KAAK,KAAK,CAAC,KAAK,GAAG,KAAK,QAAQ,KAAK,KAAK,KAAK;IACrE,MAAM,gBAAgB,QAAQ,IAAI,CAAC,MAAM,CACvC,CAAC,IAAM,EAAE,OAAO,IAAI,iBAAiB,EAAE,MAAM,KAAK;IAEpD,MAAM,iBAAiB,cAAc,MAAM,CAAC,CAAC,KAAK,IAAM,MAAM,EAAE,MAAM,EAAE,KAAK;IAE7E,cAAc;IACd,MAAM,mBAAmB,QAAQ,OAAO,IAAI,KAAK,KAAK,CAAC,KAAK,GAAG,KAAK;IACpE,MAAM,iBAAiB,IAAI,KAAK,mBAAmB,MAAM,WAAW;IACpE,MAAM,mBAAmB,KAAK,KAAK,CACjC,CAAC,KAAK,GAAG,KAAK,mBAAmB,IAAI,IAAI,CAAC,QAAQ,KAAK,KAAK,KAAK,IAAI;IAGvE,kBAAkB;IAClB,MAAM,eAAe,QAAQ,IAAI,CAAC,MAAM;IACxC,MAAM,gBAAgB,SAAS,IAAI,CAAC,MAAM;IAC1C,MAAM,iBAAiB,eAAe,IAAI,AAAC,gBAAgB,eAAgB,MAAM;IAEjF,OAAO;QACL;QACA,yBAAyB,CAAC,CAAC,EAAE,eAAe,cAAc,CAAC,SAAS;YAAE,uBAAuB;YAAG,uBAAuB;QAAE,IAAI;QAC7H,cAAc,kBAAkB;QAChC;QACA;QACA,gBAAgB,KAAK,KAAK,CAAC,iBAAiB,OAAO;QACnD,wBAAwB,yBAAyB;QACjD;QACA;IACF;AACF"}},
    {"offset": {"line": 277, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahmanbazarov/Data/programming/BedRock/src/app/api/oauth/stripe/connect/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server'\nimport { generateStateToken, setStateCookie } from '@/lib/oauth/utils'\nimport { getStripeConnectUrl } from '@/lib/oauth/stripe'\n\nexport async function GET() {\n  try {\n    if (!process.env.STRIPE_SECRET_KEY || !process.env.STRIPE_CONNECT_CLIENT_ID) {\n      return NextResponse.json({ error: 'Stripe Connect not configured' }, { status: 503 })\n    }\n\n    const state = generateStateToken('stripe', 5)\n    await setStateCookie(state)\n    const url = getStripeConnectUrl(state)\n\n    return NextResponse.redirect(url)\n  } catch (error) {\n    console.error('Stripe connect error:', error)\n    return NextResponse.redirect(\n      `${process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'}/onboarding/oauth-success?provider=stripe&error=${encodeURIComponent('Failed to initiate Stripe Connect')}`\n    )\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEO,eAAe;IACpB,IAAI;QACF,IAAI,CAAC,QAAQ,GAAG,CAAC,iBAAiB,IAAI,CAAC,QAAQ,GAAG,CAAC,wBAAwB,EAAE;YAC3E,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAgC,GAAG;gBAAE,QAAQ;YAAI;QACrF;QAEA,MAAM,QAAQ,IAAA,oJAAkB,EAAC,UAAU;QAC3C,MAAM,IAAA,gJAAc,EAAC;QACrB,MAAM,MAAM,IAAA,sJAAmB,EAAC;QAEhC,OAAO,gJAAY,CAAC,QAAQ,CAAC;IAC/B,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,yBAAyB;QACvC,OAAO,gJAAY,CAAC,QAAQ,CAC1B,GAAG,6DAAmC,wBAAwB,gDAAgD,EAAE,mBAAmB,sCAAsC;IAE7K;AACF"}}]
}