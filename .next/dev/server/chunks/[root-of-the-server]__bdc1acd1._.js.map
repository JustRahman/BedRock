{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahmanbazarov/Data/programming/BedRock/src/lib/crypto/challenge-cache.ts"],"sourcesContent":["import { createHmac } from 'crypto'\n\n// Stateless challenge verification using HMAC.\n// No in-memory state needed â€” the challenge message itself contains\n// the timestamp and HMAC so the verify endpoint can validate it.\n\nconst CHALLENGE_TTL_MS = 5 * 60 * 1000 // 5 minutes\n\nfunction getSecret(): string {\n  return process.env.OAUTH_STATE_SECRET || 'dev-fallback-secret'\n}\n\nfunction hmac(data: string): string {\n  return createHmac('sha256', getSecret()).update(data).digest('hex')\n}\n\n/**\n * Create a signed challenge message. The message includes:\n * - The wallet address\n * - A timestamp\n * - A nonce\n * - An HMAC signature\n * The client signs this message, and the verify endpoint can validate\n * the HMAC without needing to look anything up.\n */\nexport function createSignedChallenge(address: string): string {\n  const timestamp = Date.now()\n  const nonce = Math.random().toString(36).substring(2, 10)\n  const payload = `${address.toLowerCase()}:${timestamp}:${nonce}`\n  const sig = hmac(payload)\n\n  // Human-readable message that the wallet will display\n  return `BedRock Wallet Verification\\n\\nAddress: ${address}\\nTimestamp: ${timestamp}\\nNonce: ${nonce}\\nSignature: ${sig}`\n}\n\n/**\n * Parse and validate a signed challenge message.\n * Returns the original message if valid and not expired, null otherwise.\n */\nexport function validateChallenge(message: string): { valid: boolean; address?: string } {\n  try {\n    const addressMatch = message.match(/Address: (.+)/)\n    const timestampMatch = message.match(/Timestamp: (\\d+)/)\n    const nonceMatch = message.match(/Nonce: (.+)/)\n    const sigMatch = message.match(/Signature: (.+)/)\n\n    if (!addressMatch || !timestampMatch || !nonceMatch || !sigMatch) {\n      return { valid: false }\n    }\n\n    const address = addressMatch[1].trim()\n    const timestamp = parseInt(timestampMatch[1].trim())\n    const nonce = nonceMatch[1].trim()\n    const sig = sigMatch[1].trim()\n\n    // Check expiry\n    if (Date.now() - timestamp > CHALLENGE_TTL_MS) {\n      return { valid: false }\n    }\n\n    // Verify HMAC\n    const payload = `${address.toLowerCase()}:${timestamp}:${nonce}`\n    const expectedSig = hmac(payload)\n\n    if (sig !== expectedSig) {\n      return { valid: false }\n    }\n\n    return { valid: true, address }\n  } catch {\n    return { valid: false }\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA;;AAEA,+CAA+C;AAC/C,oEAAoE;AACpE,iEAAiE;AAEjE,MAAM,mBAAmB,IAAI,KAAK,KAAK,YAAY;;AAEnD,SAAS;IACP,OAAO,QAAQ,GAAG,CAAC,kBAAkB,IAAI;AAC3C;AAEA,SAAS,KAAK,IAAY;IACxB,OAAO,IAAA,mHAAU,EAAC,UAAU,aAAa,MAAM,CAAC,MAAM,MAAM,CAAC;AAC/D;AAWO,SAAS,sBAAsB,OAAe;IACnD,MAAM,YAAY,KAAK,GAAG;IAC1B,MAAM,QAAQ,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,SAAS,CAAC,GAAG;IACtD,MAAM,UAAU,GAAG,QAAQ,WAAW,GAAG,CAAC,EAAE,UAAU,CAAC,EAAE,OAAO;IAChE,MAAM,MAAM,KAAK;IAEjB,sDAAsD;IACtD,OAAO,CAAC,wCAAwC,EAAE,QAAQ,aAAa,EAAE,UAAU,SAAS,EAAE,MAAM,aAAa,EAAE,KAAK;AAC1H;AAMO,SAAS,kBAAkB,OAAe;IAC/C,IAAI;QACF,MAAM,eAAe,QAAQ,KAAK,CAAC;QACnC,MAAM,iBAAiB,QAAQ,KAAK,CAAC;QACrC,MAAM,aAAa,QAAQ,KAAK,CAAC;QACjC,MAAM,WAAW,QAAQ,KAAK,CAAC;QAE/B,IAAI,CAAC,gBAAgB,CAAC,kBAAkB,CAAC,cAAc,CAAC,UAAU;YAChE,OAAO;gBAAE,OAAO;YAAM;QACxB;QAEA,MAAM,UAAU,YAAY,CAAC,EAAE,CAAC,IAAI;QACpC,MAAM,YAAY,SAAS,cAAc,CAAC,EAAE,CAAC,IAAI;QACjD,MAAM,QAAQ,UAAU,CAAC,EAAE,CAAC,IAAI;QAChC,MAAM,MAAM,QAAQ,CAAC,EAAE,CAAC,IAAI;QAE5B,eAAe;QACf,IAAI,KAAK,GAAG,KAAK,YAAY,kBAAkB;YAC7C,OAAO;gBAAE,OAAO;YAAM;QACxB;QAEA,cAAc;QACd,MAAM,UAAU,GAAG,QAAQ,WAAW,GAAG,CAAC,EAAE,UAAU,CAAC,EAAE,OAAO;QAChE,MAAM,cAAc,KAAK;QAEzB,IAAI,QAAQ,aAAa;YACvB,OAAO;gBAAE,OAAO;YAAM;QACxB;QAEA,OAAO;YAAE,OAAO;YAAM;QAAQ;IAChC,EAAE,OAAM;QACN,OAAO;YAAE,OAAO;QAAM;IACxB;AACF"}},
    {"offset": {"line": 122, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahmanbazarov/Data/programming/BedRock/src/lib/rate-limit.ts"],"sourcesContent":["const rateLimitMap = new Map<string, { count: number; resetAt: number }>()\n\n// Cleanup stale entries every 5 minutes\nsetInterval(() => {\n  const now = Date.now()\n  for (const [key, entry] of rateLimitMap) {\n    if (now > entry.resetAt) {\n      rateLimitMap.delete(key)\n    }\n  }\n}, 5 * 60_000)\n\nexport function checkRateLimit(\n  key: string,\n  maxRequests: number = 10,\n  windowMs: number = 60_000\n): { allowed: boolean; remaining: number; resetIn: number } {\n  const now = Date.now()\n  const entry = rateLimitMap.get(key)\n\n  if (!entry || now > entry.resetAt) {\n    rateLimitMap.set(key, { count: 1, resetAt: now + windowMs })\n    return { allowed: true, remaining: maxRequests - 1, resetIn: windowMs }\n  }\n\n  if (entry.count >= maxRequests) {\n    return { allowed: false, remaining: 0, resetIn: entry.resetAt - now }\n  }\n\n  entry.count++\n  return { allowed: true, remaining: maxRequests - entry.count, resetIn: entry.resetAt - now }\n}\n\nexport function getClientIp(request: Request): string {\n  const forwarded = request.headers.get('x-forwarded-for')\n  const realIp = request.headers.get('x-real-ip')\n  return forwarded?.split(',')[0]?.trim() || realIp || 'unknown'\n}\n"],"names":[],"mappings":";;;;;;AAAA,MAAM,eAAe,IAAI;AAEzB,wCAAwC;AACxC,YAAY;IACV,MAAM,MAAM,KAAK,GAAG;IACpB,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,aAAc;QACvC,IAAI,MAAM,MAAM,OAAO,EAAE;YACvB,aAAa,MAAM,CAAC;QACtB;IACF;AACF,GAAG,IAAI;AAEA,SAAS,eACd,GAAW,EACX,cAAsB,EAAE,EACxB,WAAmB,MAAM;IAEzB,MAAM,MAAM,KAAK,GAAG;IACpB,MAAM,QAAQ,aAAa,GAAG,CAAC;IAE/B,IAAI,CAAC,SAAS,MAAM,MAAM,OAAO,EAAE;QACjC,aAAa,GAAG,CAAC,KAAK;YAAE,OAAO;YAAG,SAAS,MAAM;QAAS;QAC1D,OAAO;YAAE,SAAS;YAAM,WAAW,cAAc;YAAG,SAAS;QAAS;IACxE;IAEA,IAAI,MAAM,KAAK,IAAI,aAAa;QAC9B,OAAO;YAAE,SAAS;YAAO,WAAW;YAAG,SAAS,MAAM,OAAO,GAAG;QAAI;IACtE;IAEA,MAAM,KAAK;IACX,OAAO;QAAE,SAAS;QAAM,WAAW,cAAc,MAAM,KAAK;QAAE,SAAS,MAAM,OAAO,GAAG;IAAI;AAC7F;AAEO,SAAS,YAAY,OAAgB;IAC1C,MAAM,YAAY,QAAQ,OAAO,CAAC,GAAG,CAAC;IACtC,MAAM,SAAS,QAAQ,OAAO,CAAC,GAAG,CAAC;IACnC,OAAO,WAAW,MAAM,IAAI,CAAC,EAAE,EAAE,UAAU,UAAU;AACvD"}},
    {"offset": {"line": 175, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahmanbazarov/Data/programming/BedRock/src/app/api/crypto/challenge/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server'\nimport { createSignedChallenge } from '@/lib/crypto/challenge-cache'\nimport { checkRateLimit, getClientIp } from '@/lib/rate-limit'\n\nexport async function POST(request: Request) {\n  const ip = getClientIp(request)\n  const { allowed, resetIn } = checkRateLimit(`crypto-challenge:${ip}`, 20, 60_000)\n  if (!allowed) {\n    return NextResponse.json(\n      { error: 'Too many requests' },\n      { status: 429, headers: { 'Retry-After': String(Math.ceil(resetIn / 1000)) } }\n    )\n  }\n\n  try {\n    const { address } = await request.json()\n    if (!address || typeof address !== 'string') {\n      return NextResponse.json({ error: 'Address is required' }, { status: 400 })\n    }\n\n    const message = createSignedChallenge(address)\n\n    return NextResponse.json({ message })\n  } catch {\n    return NextResponse.json({ error: 'Failed to generate challenge' }, { status: 500 })\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEO,eAAe,KAAK,OAAgB;IACzC,MAAM,KAAK,IAAA,4IAAW,EAAC;IACvB,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,GAAG,IAAA,+IAAc,EAAC,CAAC,iBAAiB,EAAE,IAAI,EAAE,IAAI;IAC1E,IAAI,CAAC,SAAS;QACZ,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAoB,GAC7B;YAAE,QAAQ;YAAK,SAAS;gBAAE,eAAe,OAAO,KAAK,IAAI,CAAC,UAAU;YAAO;QAAE;IAEjF;IAEA,IAAI;QACF,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,QAAQ,IAAI;QACtC,IAAI,CAAC,WAAW,OAAO,YAAY,UAAU;YAC3C,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAsB,GAAG;gBAAE,QAAQ;YAAI;QAC3E;QAEA,MAAM,UAAU,IAAA,qKAAqB,EAAC;QAEtC,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE;QAAQ;IACrC,EAAE,OAAM;QACN,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAA+B,GAAG;YAAE,QAAQ;QAAI;IACpF;AACF"}}]
}